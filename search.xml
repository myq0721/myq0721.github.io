<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>OpenGL中Debug</title>
      <link href="/2023/02/14/opengl-zhong-debug/"/>
      <url>/2023/02/14/opengl-zhong-debug/</url>
      
        <content type="html"><![CDATA[<h3 id="glGetError"><a href="#glGetError" class="headerlink" title="glGetError"></a>glGetError</h3><p>兼容所有版本，使用方法简单</p><p>调用后只返回一个任意的错误标志，所以要循环调用，而且使用麻烦，要在所有要检查的前后分别打上下面两段代码ww</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">static void GLClearError()//查错{while (glGetError() != GL_NO_ERROR);}static void GLCheckError()//输出错误信息{while (GLenum error =  glGetError()){std::cout &lt;&lt; "[OpenGL Error!](" &lt;&lt; error &lt;&lt; ")" &lt;&lt; std::endl;}}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>且OpenGl用十六进制定义了他所有的错误码，需要把拿到的错误码转换成十六进制，然后去glew头文件里搜</p><br>断言改进版<br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#define ASSERT(x) if(!(x)) __debugbreak();static void GLClearError()//查错{while (glGetError() != GL_NO_ERROR);}static bool GLLogCall(){while (GLenum error =  glGetError()){std::cout &lt;&lt; "[OpenGL Error!](" &lt;&lt; error &lt;&lt; ")" &lt;&lt; std::endl;return false;}return true;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-3之后，glMessageCallback"><a href="#4-3之后，glMessageCallback" class="headerlink" title="4.3之后，glMessageCallback"></a>4.3之后，glMessageCallback</h3><p>允许我们指定一个指向OpenGL的函数指针，OpenGL会调用我们的那个函数</p><p>比glGetError好用多了awa~，不需要一直问（</p><p>错误信息也比glGetError详细</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL_读取外部shader、建立索引缓冲区</title>
      <link href="/2023/02/14/opengl-du-qu-wai-bu-shader/"/>
      <url>/2023/02/14/opengl-du-qu-wai-bu-shader/</url>
      
        <content type="html"><![CDATA[<p>上次通过字符串的形式写了简单的顶点和片元着色器</p><p>这次优化为把shader放在外部，用类状态机的方式读取</p><p>为shader的编写带来了极大便利</p><p>见代码</p><br><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include&lt;iostream&gt;#include&lt;fstream&gt;#include&lt;string&gt;#include&lt;sstream&gt;struct ShaderProgramSource{std::string VertexShader;std::string FragmentShader;};static ShaderProgramSource ParseShader(const std::string&amp; filepath){std::ifstream stream(filepath);enum class ShaderType{NONE = -1, VERTEX = 0, FRAGMENT = 1};std::string line;std::stringstream ss[2];ShaderType type = ShaderType::NONE;while (getline(stream, line)){if (line.find("#shader") != std::string::npos){if (line.find("vertex") != std::string::npos)type = ShaderType::VERTEX;else if (line.find("fragment") != std::string::npos)type = ShaderType::FRAGMENT;}else{ss[int(type)] &lt;&lt; line &lt;&lt; '\n';}}return{ ss[0].str(),ss[1].str() };}static unsigned int CompileShader(unsigned int type, const std::string&amp; source){unsigned int id = glCreateShader(type);const char* src = source.c_str();glShaderSource(id, 1, &amp;src, nullptr);glCompileShader(id);int result;glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);if (result == GL_FALSE){int length;glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);char* message = (char*)alloca(length * sizeof(char));glGetShaderInfoLog(id, length, &amp;length, message);std::cout &lt;&lt; "Failed To Compile" &lt;&lt; (type == GL_VERTEX_SHADER ? "vertex" : "fragmenrt") &lt;&lt; " Shader Nya~" &lt;&lt; std::endl;std::cout &lt;&lt; message &lt;&lt; std::endl;glDeleteShader(id);return 0;}return id;}static unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader){unsigned int program = glCreateProgram();unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);glAttachShader(program, vs);glAttachShader(program, fs);glLinkProgram(program);glValidateProgram(program);glDeleteShader(vs);glDeleteShader(fs);return program;}int main(void){GLFWwindow* window;/* Initialize the library */if (!glfwInit())return -1;glewInit();/* Create a windowed mode window and its OpenGL context */window = glfwCreateWindow(640, 480, "OpenGl", NULL, NULL);if (!window){glfwTerminate();return -1;}/* Make the window's context current */glfwMakeContextCurrent(window);if (glewInit() != GLEW_OK) {std::cout &lt;&lt; "Error" &lt;&lt; std::endl;}std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;float position[] = {-0.5f, -0.5f,//0 0.5f, -0.5f,//1 0.5f,  0.5f,//2 -0.5f, 0.5f,//3};unsigned int indices[] = {0,1,2,2,3,0};unsigned int buffer;glGenBuffers(1, &amp;buffer);glBindBuffer(GL_ARRAY_BUFFER, buffer);glBufferData(GL_ARRAY_BUFFER, 2 * 6 * sizeof(float), position, GL_STATIC_DRAW);glEnableVertexAttribArray(0);glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);/*glbindbuffer(gl_array_buffer, 0);*/unsigned int ibo;//索引缓冲区对象,必须无符号整形glGenBuffers(1, &amp;ibo);glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);//索引缓冲区插槽glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), indices, GL_STATIC_DRAW);ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");std::cout &lt;&lt; "VERREX" &lt;&lt; std::endl;std::cout &lt;&lt; source.VertexShader &lt;&lt; std::endl;std::cout &lt;&lt; "FRAGMENT" &lt;&lt; std::endl;std::cout &lt;&lt; source.FragmentShader &lt;&lt; std::endl;unsigned int shader = CreateShader(source.VertexShader,source.FragmentShader);glUseProgram(shader);/* Loop until the user closes the window */while (!glfwWindowShouldClose(window)){/* Render here */glClear(GL_COLOR_BUFFER_BIT);glDrawElements(GL_TRIANGLES, 6,GL_UNSIGNED_INT, nullptr);/* Swap front and back buffers */glfwSwapBuffers(window);/* Poll for and process events */glfwPollEvents();}glDeleteProgram(shader);glfwTerminate();return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>chatgpt的诗集</title>
      <link href="/2023/02/13/chatgpt-de-shi-ji/"/>
      <url>/2023/02/13/chatgpt-de-shi-ji/</url>
      
        <content type="html"><![CDATA[<p>孤舟独泊，漂流远方<br>情感如涛，无处安放<br>梦中归途，迷雾里消逝<br>日复一日，望眼已穿</p><p>冷落寂寥，如萤火般闪烁<br>探索真理，却见虚假交错<br>对爱的执着，风筝追逐风吹<br>山河无情</p><p>追忆年少，那无忧无虑的笑颜<br>心中热望，却遭冷酷抹灭<br>游走人间，寻找逃离孤独的道<br>沉沦的灯塔，仍在闪烁</p><p>现代生活，如被岁月掩埋的海市蜃楼<br>对爱的期盼，如彩虹般未来追逐<br>渴望真情，在迷失中寻方向<br>勇敢前行，终有一天彼岸到达。</p>]]></content>
      
      
      <categories>
          
          <category> ChatGPT </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 诗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenGL中的shader</title>
      <link href="/2023/02/12/opengl-zhong-de-shader/"/>
      <url>/2023/02/12/opengl-zhong-de-shader/</url>
      
        <content type="html"><![CDATA[<p>主要是顶点着色器与片段着色器（这之间已经顶点着色器之前还有许多阶段，此处省略</p><p>顶点着色器为我们试图渲染的每个顶点调用，与实际图形无关，只是指定了你想要的位置的方式，也被用来解析数据从属性到下一阶段（在片段着色器</p><p>片段着色器为每个需要光栅化的像素运行一次，可以理解为涂色的像素格子，调用次数取决于需要绘制的像素数量</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;GL/glew.h&gt;#include &lt;GLFW/glfw3.h&gt;#include&lt;iostream&gt;//创建着色器static unsigned int CompileShader(unsigned int type, const std::string&amp; source){    unsigned int id = glCreateShader(type);    const char* src = source.c_str();    glShaderSource(id, 1, &amp;src, nullptr);    glCompileShader(id);    int result;    glGetShaderiv(id, GL_COMPILE_STATUS, &amp;result);    if (result == GL_FALSE)    {        int length;        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &amp;length);        char* message = (char*)alloca(length * sizeof(char));        glGetShaderInfoLog(id, length, &amp;length, message);        std::cout &lt;&lt; "Failed To Compile"&lt;&lt;(type == GL_VERTEX_SHADER ? "vertex" : "fragmenrt")&lt;&lt;" Shader Nya~" &lt;&lt; std::endl;        std::cout &lt;&lt; message &lt;&lt; std::endl;        glDeleteShader(id);        return 0;    }    return id;}static unsigned int CreateShader(const std::string&amp; vertexShader, const std::string&amp; fragmentShader) {    unsigned int program = glCreateProgram();    unsigned int vs = CompileShader(GL_VERTEX_SHADER,vertexShader);    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);    glAttachShader(program, vs);    glAttachShader(program, fs);    glLinkProgram(program);    glValidateProgram(program);    glDeleteShader(vs);    glDeleteShader(fs);    return program;}int main(void){    GLFWwindow* window;    /* Initialize the library */    if (!glfwInit())        return -1;    glewInit();    /* Create a windowed mode window and its OpenGL context */    window = glfwCreateWindow(640, 480, "OpenGl", NULL, NULL);    if (!window)    {        glfwTerminate();        return -1;    }    /* Make the window's context current */    glfwMakeContextCurrent(window);    if (glewInit() != GLEW_OK) {        std::cout &lt;&lt; "Error" &lt;&lt; std::endl;    }    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;    float position[6] = {        -0.5f, -0.5f,         0.0f,  0.5f,         0.5f, -0.5f    };    unsigned int buffer;    glGenBuffers(1, &amp;buffer);    glBindBuffer(GL_ARRAY_BUFFER, buffer);    glBufferData(GL_ARRAY_BUFFER,sizeof(position),position,GL_STATIC_DRAW);    glEnableVertexAttribArray(0);    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);    glBindBuffer(GL_ARRAY_BUFFER, 0);    //把着色器作为字符串传进去    //这并不是好的方法（    //下期解决    std::string vertexShader =         "#version 330 core\n"        "\n"        "layout(location = 0) in vec4 position;\n"        "\n"        "void main()\n"        "{\n"        "   gl_Position = position;\n"        "}\n";    std::string fragmentShader =        "#version 330 core\n"        "\n"        "layout(location = 0) out vec4 color;"        "\n"        "void main()\n"        "{\n"        "   color = vec4(1.0, 0.0, 0.0, 1.0);\n"        "}\n";    unsigned int shader = CreateShader(vertexShader,fragmentShader);    glUseProgram(shader);    /* Loop until the user closes the window */    while (!glfwWindowShouldClose(window))    {        /* Render here */        glClear(GL_COLOR_BUFFER_BIT);        glDrawArrays(GL_TRIANGLES,0,3);        /* Swap front and back buffers */        glfwSwapBuffers(window);        /* Poll for and process events */        glfwPollEvents();    }    glfwTerminate();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>游戏开发相关比赛</title>
      <link href="/2023/02/11/you-xi-kai-fa-xiang-guan-bi-sai/"/>
      <url>/2023/02/11/you-xi-kai-fa-xiang-guan-bi-sai/</url>
      
        <content type="html"><![CDATA[<h2 id="一、中国大学生计算机设计大赛"><a href="#一、中国大学生计算机设计大赛" class="headerlink" title="一、中国大学生计算机设计大赛"></a>一、<a href="http://jsjds.blcu.edu.cn/info/1041/1734.htm">中国大学生计算机设计大赛</a></h2><p>其中： 2023年（第16届）中国大学生计算机设计大赛，（9）数媒游戏与交互设计；杭州；浙江传媒学院/杭州电子科技大学/浙江音乐学院；8.18～8.22</p><p>相对简单，容易拿奖(大概)</p><h2 id="二、CiGA-Game-Jam"><a href="#二、CiGA-Game-Jam" class="headerlink" title="二、CiGA Game Jam"></a>二、<a href="https://www.ciga.me/cgj">CiGA Game Jam</a></h2><p>已知21年开发时间为2021年7月9日17：00（主题发布）-2021年7月11日16：00 （线下展示）</p><p>线下48小时游戏极限开发活动。(也可线上)</p><h2 id="各大厂的比赛"><a href="#各大厂的比赛" class="headerlink" title="各大厂的比赛"></a>各大厂的比赛</h2><h3 id="鹅厂"><a href="#鹅厂" class="headerlink" title="鹅厂"></a><a href="https://gameinstitute.qq.com/college">鹅厂</a></h3><p>5月7日-7月30日</p><h3 id="猪厂"><a href="#猪厂" class="headerlink" title="猪厂"></a><a href="https://game.academy.163.com/activity">猪厂</a></h3><p>22年的刚结束</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p><a href="https://gamecreator.g-bits.com/pc/sh_rules.html">吉比特未来游戏制作人</a>，完美世界文创，莉莉丝达芬奇……</p><h2 id="indiePlay"><a href="#indiePlay" class="headerlink" title="indiePlay"></a><a href="https://indienova.com/">indiePlay</a></h2><p>独立游戏界的比赛,有含金量,奖金有些拮据</p><h2 id="UGDAP"><a href="#UGDAP" class="headerlink" title="UGDAP"></a><a href="https://www.ugdap.com/">UGDAP</a></h2><p>同上</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 游戏开发杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mini引擎(Ayana engine)开发日志</title>
      <link href="/2023/02/07/mini-yin-qing-kai-fa-ri-zhi/"/>
      <url>/2023/02/07/mini-yin-qing-kai-fa-ri-zhi/</url>
      
        <content type="html"><![CDATA[<h1 id="第二部分（02-x2F-18"><a href="#第二部分（02-x2F-18" class="headerlink" title="第二部分（02/18"></a>第二部分（02/18</h1><h2 id="项目设置"><a href="#项目设置" class="headerlink" title="项目设置"></a>项目设置</h2><blockquote><p>创建Ayana DLL文件</p></blockquote><blockquote><p>完成与Ayana链接的Sandbox启动项</p></blockquote><blockquote><p>建立GitHub存储库</p></blockquote><p>github : <a href="https://github.com/myq0721/Ayana">https://github.com/myq0721/Ayana</a></p><p>c++17,x64,vs2017(v141)</p><blockquote><p><em>SDK版本要改为10.0.19041.0,不然会有无法打开源文件的错</em></p></blockquote><p>配置：</p><p>输出目录:   $(SolutionDir)bin\$(Configuration)-$(Platform)\$(ProjectName)\</p><p>中间目录: $(SolutionDir)bin-int\$(Configuration)-$(Platform)\$(ProjectName)\</p><p>完成基础配置并链接dl与exe后</p><p>测试一:</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">pragma</span> <span class="token expression">once</span></span><span class="token keyword">namespace</span> Ayana <span class="token punctuation">{</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Test.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span><span class="token keyword">namespace</span> Ayana <span class="token punctuation">{</span><span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Hello Ayana!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">已启动生成…1&gt;------ 已启动生成: 项目: Ayana, 配置: Debug x64 ------1&gt;Test.cpp1&gt;  正在创建库 G:\VS\Ayana\bin\Debug-x64\Ayana\Ayana.lib 和对象 G:\VS\Ayana\bin\Debug-x64\Ayana\Ayana.exp1&gt;Ayana.vcxproj -&gt; G:\VS\Ayana\bin\Debug-x64\Ayana\Ayana.dll========== 生成: 成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ==========<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试二</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> Ayana <span class="token punctuation">{</span><span class="token function">__declspec</span><span class="token punctuation">(</span>dllimport<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Ayana</span><span class="token double-colon punctuation">::</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">Hello Ayana!G:\VS\Ayana\bin\Debug-x64\Sandbox\Sandbox.exe (进程 15832)已退出，代码为 0。要在调试停止时自动关闭控制台，请启用“工具”-&gt;“选项”-&gt;“调试”-&gt;“调试停止时自动关闭控制台”。按任意键关闭此窗口. . .<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>好诶，环境准备完毕！~</p><h2 id="入口点"><a href="#入口点" class="headerlink" title="入口点"></a>入口点</h2><blockquote><p>创建宏，控制导入和导出</p></blockquote><blockquote><p>完成基本的入口点，并且将入口移动到了引擎内部并进行了适当的处理</p></blockquote><blockquote><p>推到github上，并通过.gitignore忽略部分文件</p></blockquote><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">//根据building的DLL文件决定导入或导出</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">AY_PLATFORM_WINDOWS</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">AY_BUILD_DLL</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AYANA_API</span> <span class="token expression"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllexport<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">AYANA_API</span> <span class="token expression"><span class="token function">__declspec</span><span class="token punctuation">(</span>dllimport<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span> <span class="token comment">// AY_BUILD_DLL</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">error</span> <span class="token expression">Ayana only support windows<span class="token operator">!</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c" data-language="c"><code class="language-c">git resetgit add <span class="token operator">*</span>git status<span class="token comment">//确认无误后提交设置</span>git commit <span class="token operator">-</span>m <span class="token string">"Setup basic Application and Entry Point."</span><span class="token comment">//结果</span>G<span class="token operator">:</span>\VS\Ayana<span class="token operator">&gt;</span>git commit <span class="token operator">-</span>m <span class="token string">"Setup basic Application and Entry Point."</span><span class="token punctuation">[</span>main <span class="token number">43e7</span>b11<span class="token punctuation">]</span> Setup basic Application and Entry Point<span class="token punctuation">.</span> <span class="token number">12</span> files changed<span class="token punctuation">,</span> <span class="token number">385</span> <span class="token function">insertions</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> create mode <span class="token number">100644</span> <span class="token punctuation">.</span>gitignore create mode <span class="token number">100644</span> Ayana<span class="token punctuation">.</span>sln create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>Ayana<span class="token punctuation">.</span>vcxproj create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>Ayana<span class="token punctuation">.</span>vcxproj<span class="token punctuation">.</span>filters create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>src<span class="token operator">/</span>Ayana<span class="token punctuation">.</span>h create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>src<span class="token operator">/</span>Ayana<span class="token operator">/</span>Application<span class="token punctuation">.</span>cpp create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>src<span class="token operator">/</span>Ayana<span class="token operator">/</span>Application<span class="token punctuation">.</span>h create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>src<span class="token operator">/</span>Ayana<span class="token operator">/</span>Core<span class="token punctuation">.</span>h create mode <span class="token number">100644</span> Ayana<span class="token operator">/</span>src<span class="token operator">/</span>Ayana<span class="token operator">/</span>EntryPoint<span class="token punctuation">.</span>h create mode <span class="token number">100644</span> Sandbox<span class="token operator">/</span>Sandbox<span class="token punctuation">.</span>vcxproj create mode <span class="token number">100644</span> Sandbox<span class="token operator">/</span>Sandbox<span class="token punctuation">.</span>vcxproj<span class="token punctuation">.</span>filters create mode <span class="token number">100644</span> Sandbox<span class="token operator">/</span>src<span class="token operator">/</span>SandboxApp<span class="token punctuation">.</span>cpp <span class="token comment">//OK，没问题，推过去</span> git push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><em>错误记录1</em></p><pre class="line-numbers language-none"><code class="language-none">&gt;error: src refspec master does not match any.&gt;error: failed to push some refs to <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><em>原因：<br>1.本地git仓库目录下为空;<br>2.本地仓库add后未commit;<br>3.git init错误;<br>用命令 git add + 文件名，把文件添加到仓库就行 ，然后正常push</em></p></blockquote><blockquote><p><em>错误记录2</em></p><pre class="line-numbers language-none"><code class="language-none">&gt;remote: Invalid username or password. fatal: Authentication failed for 'https://github.com/myq0721/Ayana.git/'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>原因：长时间未上传过远程仓库或者存在多个远程仓库。<br>解决方案：<br>需要获取一个新的 token</em></p></blockquote><p>–02/21</p><h2 id="添加日志功能"><a href="#添加日志功能" class="headerlink" title="添加日志功能"></a>添加日志功能</h2><blockquote><p>通过SPD log格式化不同的类型</p></blockquote><blockquote><p>输出信息，错误（红色，警告（黄色等</p></blockquote><blockquote><p>通过宏使得更容易编辑，还可以使代码剥离出来</p></blockquote><p>需要打印文本，数字，字符，对象，指针等，所以调用SPD log支持</p><p><a href="https://github.com/gabime/spdlog">https://github.com/gabime/spdlog</a></p><pre class="line-numbers language-none"><code class="language-none">git submodule add https://github.com/gabime/spdlog.git Ayana/vendor/spdlog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后添加到c++/常规/附加包含目录中即可</p><blockquote><p><em>错误记录1：</em></p><pre class="line-numbers language-none"><code class="language-none">s_CoreLogger = spdlog::stdout_color_mt("AYANA");<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>错误(活动)E0135namespace “spdlog” 没有成员 “stdout_color_mt”AyanaG:\VS\Ayana\Ayana\src\Ayana\Log.cpp11</p><p><em>在查阅github上的示例后，发现需添加</em></p><pre class="line-numbers language-none"><code class="language-none">&gt;#include "spdlog/sinks/stdout_color_sinks.h"<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><br><br></blockquote><blockquote><p><em>错误记录2：完成后发现Ayana可以成功编译，Sandbox找不到文件</em></p><pre class="line-numbers language-none"><code class="language-none">&gt;atal error C1083: 无法打开包括文件: “spdlog/spdlog.h”: No such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><em>找了半天，原因是属性中c++的附加包含目录，最后一项不慎加了分号，真是傻呗设计</em><br><br><br><br></p></blockquote><p><br><br></p><h1 id="第一部分（02-x2F-08"><a href="#第一部分（02-x2F-08" class="headerlink" title="第一部分（02/08"></a>第一部分（02/08</h1><p>开了天坑了（悲）</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="一、底层与第三方包"><a href="#一、底层与第三方包" class="headerlink" title="一、底层与第三方包"></a>一、底层与第三方包</h3><h4 id="openGL"><a href="#openGL" class="headerlink" title="openGL"></a><a href="https://www.opengl.org/">openGL</a></h4><p><a href="https://learnopengl-cn.github.io/#_1">LearnOpenGL_CN</a></p><h4 id="PhysX"><a href="#PhysX" class="headerlink" title="PhysX"></a><a href="https://developer.nvidia.cn/zh-cn/physx-sdk">PhysX</a></h4><p><a href="PhysX/4.1/documentation">PhysX4.1documentation</a></p><h4 id="boost"><a href="#boost" class="headerlink" title="boost"></a><a href="https://www.boost.org/">boost</a></h4><p><a href="https://www.boost.org/doc/libs/">Boost Library Documentation</a></p><p><a href="https://github.com/wuye9036/BoostLibrariesCheetsheetChn">速查手册</a></p><p><a href="https://www.cnblogs.com/lidabo/p/9294874.html">中文教程</a></p><h4 id="STL-x2F-STLPort"><a href="#STL-x2F-STLPort" class="headerlink" title="STL/STLPort"></a><a href="https://learn.microsoft.com/zh-cn/cpp/standard-library/cpp-standard-library-reference?view=msvc-170">STL/STLPort</a></h4><p><a href="http://c.biancheng.net/stl/">c语言中文网</a></p><h4 id="Kynapse-AI"><a href="#Kynapse-AI" class="headerlink" title="Kynapse(AI)"></a>Kynapse(AI)</h4><h4 id="Euphoria（动画）"><a href="#Euphoria（动画）" class="headerlink" title="Euphoria（动画）"></a>Euphoria（动画）</h4><h4 id="other"><a href="#other" class="headerlink" title="other"></a>other</h4><h3 id="二、平台独立层"><a href="#二、平台独立层" class="headerlink" title="二、平台独立层"></a>二、平台独立层</h3><h4 id="平台检测"><a href="#平台检测" class="headerlink" title="平台检测"></a>平台检测</h4><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token function">defined</span><span class="token punctuation">(</span>WIN32<span class="token punctuation">)</span></span></span><span class="token comment">// Win32 Platform</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Win32Window.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Win32FileSystem.h"</span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Win32Timer.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="原子数据类型"><a href="#原子数据类型" class="headerlink" title="原子数据类型"></a>原子数据类型</h4><p>数据类型和平台、编译器相关，但基本不涉及平台相关函数，对原子数据类型的确定，主要通过对平台特定数据类型使用typedef进行类型定义。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> uint32<span class="token punctuation">;</span><span class="token comment">// 4B</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">short</span> uint16<span class="token punctuation">;</span><span class="token comment">// 2B</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> uint8<span class="token punctuation">;</span><span class="token comment">// 1B</span><span class="token keyword">typedef</span> <span class="token keyword">int</span> int32<span class="token punctuation">;</span><span class="token comment">// 4B</span><span class="token keyword">typedef</span> <span class="token keyword">short</span> int16<span class="token punctuation">;</span><span class="token comment">// 2B</span><span class="token keyword">typedef</span> <span class="token keyword">char</span> int8<span class="token punctuation">;</span><span class="token comment">// 1B</span><span class="token comment">//MSVC</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> __int64 uint64<span class="token punctuation">;</span><span class="token comment">// 8B</span><span class="token keyword">typedef</span> __int64 int64<span class="token punctuation">;</span><span class="token comment">// 8B</span><span class="token comment">//其它编译器</span><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> uint64<span class="token punctuation">;</span><span class="token comment">// 8B</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> <span class="token keyword">long</span> int64<span class="token punctuation">;</span><span class="token comment">// 8B</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><em>此外，与数据相关的问题还包括大小端: 大小端一般与处理器采用的架构相关。 Intel x86, MOS Technology 6502, Z80, VAX, PDP-11都是小端模式(Little Endian)。 Motorola 6800, Motorola 68000, PowerPC 970, System/370, SPARC(除V9外)为大端模式(Big Endian)。 ARM, PowerPC(除PowerPC 970外), DEC Alpha, SPARC V9, MIPS, PA-RISC, IA64的字节序是可配置的。</em></p><h4 id="高分辨率时钟"><a href="#高分辨率时钟" class="headerlink" title="高分辨率时钟"></a>高分辨率时钟</h4><p>时钟作为一个游戏引擎最基本的模块，在很多方面都会使用到，如FPS统计，游戏时间线，物理系统等。 时钟模块的主要作用是获取当前时间。 C语言的time.h库提供了一些基本的时间获取函数，如下。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 从 1970-01-01 00:00:00 GMT 以来消逝的秒数</span>time_t seconds <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取时分秒结构</span><span class="token keyword">struct</span> <span class="token class-name">tm</span><span class="token operator">*</span> Current <span class="token operator">=</span> <span class="token function">localtime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 从程序启动到 clock() 调用，所消耗的CPU时间</span>clock_t ticks <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 转换成秒</span><span class="token keyword">long</span> ElapsedSecond <span class="token operator">=</span> ticks <span class="token operator">/</span> CLOCKS_PER_SEC<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这些函数只能提供秒级精度，对于一些对时间要求不高的程序，直接使用这些函数就好。 但对游戏引擎而言，秒级精度是不够的，最少需要毫秒级精度。因此就需要使用到与平台相关的一些函数。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Win32<span class="token comment">// 包含 windows.h</span><span class="token keyword">static</span> LARGE_INTEGER m_StartTime<span class="token punctuation">;</span><span class="token keyword">static</span> LONGLONG m_LastTime<span class="token punctuation">;</span><span class="token keyword">static</span> DWORD m_StartTick<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">QueryPerformanceFrequency</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_StartTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    m_StartTick <span class="token operator">=</span> <span class="token function">GetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m_LastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">// 参考 OGRE getMilliseconds， 获取毫秒</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">getMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    LARGE_INTEGER frequency<span class="token punctuation">;</span>    <span class="token function">QueryPerformanceFrequency</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>frequency<span class="token punctuation">)</span><span class="token punctuation">;</span>    LARGE_INTEGER endTime<span class="token punctuation">;</span>    <span class="token function">QueryPerformanceCounter</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>endTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    LONGLONG TimeOffset <span class="token operator">=</span> endTime<span class="token punctuation">.</span>QuadPart <span class="token operator">-</span> m_StartTime<span class="token punctuation">.</span>QuadPart<span class="token punctuation">;</span>    <span class="token comment">// 毫秒：* 1000， 微秒：* 1000000</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> Ticks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> TimeOffset <span class="token operator">/</span> frequency<span class="token punctuation">.</span>QuadPart<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> check <span class="token operator">=</span> <span class="token function">GetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> m_StartTick<span class="token punctuation">;</span>    <span class="token keyword">signed</span> <span class="token keyword">long</span> msecOff <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">signed</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span>Ticks <span class="token operator">-</span> check<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msecOff <span class="token operator">&lt;</span> <span class="token operator">-</span><span class="token number">100</span> <span class="token operator">||</span> msecOff <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        LONGLONG adjust <span class="token operator">=</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>min<span class="token punctuation">)</span><span class="token punctuation">(</span>msecOff <span class="token operator">*</span> frequency<span class="token punctuation">.</span>QuadPart <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">,</span> TimeOffset <span class="token operator">-</span> m_LastTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        m_StartTime<span class="token punctuation">.</span>QuadPart <span class="token operator">+=</span> adjust<span class="token punctuation">;</span>        TimeOffset <span class="token operator">-=</span> adjust<span class="token punctuation">;</span>        Ticks <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1000</span> <span class="token operator">*</span> TimeOffset <span class="token operator">/</span> frequency<span class="token punctuation">.</span>QuadPart<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    m_LastTime <span class="token operator">=</span> TimeOffset<span class="token punctuation">;</span>    <span class="token keyword">return</span> Ticks<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Unix<span class="token operator">/</span>Linux<span class="token comment">// 包含 sys/time.h</span><span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> m_StartTime<span class="token punctuation">;</span><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m_StartTime<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">getMilliseconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">struct</span> <span class="token class-name">timeval</span> endTime<span class="token punctuation">;</span>    <span class="token function">gettimeofday</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>endTime<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// timeval 由 tv_sec(秒)， tv_usec(微秒) 共同组成</span>    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> elapsedTime <span class="token operator">=</span> <span class="token punctuation">(</span>endTime<span class="token punctuation">.</span>tv_sec <span class="token operator">-</span> m_StartTime<span class="token punctuation">.</span>tv_sec<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span>    elapsedTime <span class="token operator">+=</span> <span class="token punctuation">(</span>endTime<span class="token punctuation">.</span>tv_usec <span class="token operator">-</span> m_StartTime<span class="token punctuation">.</span>tv_usec<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">1000</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> elapsedTime<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>游戏引擎的一个重要的功能就是资源管理，而文件系统则是资源管理的基石。 文件系统的主要作用是管理文件、文件夹，必须实现文件的存取，目录的创建、删除、读取等。</p><p>1、文件</p><p>关于文件的存取，既可以使用C中的FILE相关操作函数，也可以使用C++中的文件流对象。 当然各个操作系统也都提供了对应的用于文件操作的API。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Win32<span class="token comment">// #include&lt;windows.h&gt;</span>HANDLE WINAPI <span class="token function">CreateFile</span><span class="token punctuation">(</span>  _In_      LPCTSTR lpFileName<span class="token punctuation">,</span>  _In_      DWORD dwDesiredAccess<span class="token punctuation">,</span>  _In_      DWORD dwShareMode<span class="token punctuation">,</span>  _In_opt_  LPSECURITY_ATTRIBUTES lpSecurityAttributes<span class="token punctuation">,</span>  _In_      DWORD dwCreationDisposition<span class="token punctuation">,</span>  _In_      DWORD dwFlagsAndAttributes<span class="token punctuation">,</span>  _In_opt_  HANDLE hTemplateFile<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Unix<span class="token operator">/</span>Linux<span class="token comment">//#include &lt;fcntl.h&gt;</span><span class="token keyword">int</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>path<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> mode_t mode<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>2、目录(文件夹)</p><p>Linux和Windows中都有dirent.h这个头文件，但是里面定义的函数却是不相同的。 Linux中的dirent.h提供的函数能打开目录，关闭目录，遍历目录文件。 而Windows中的dirent.h只提供了创建目录、删除目录、进入目录，已经获取当前路径等功能，并没有提供遍历目录文件的功能。 Windows中遍历目录文件的函数在io.h中。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Win32<span class="token comment">// dirent.h</span><span class="token keyword">int</span> <span class="token function">chdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">mkdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">rmdir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">getcwd</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span> buf<span class="token punctuation">,</span> <span class="token keyword">int</span> buffsize<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// io.h</span>intptr_t <span class="token function">_findfirst</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>pattern<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">_finddata_t</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">_findnext</span><span class="token punctuation">(</span>intptr_t id<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">_finddata_t</span> <span class="token operator">*</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">_findclose</span><span class="token punctuation">(</span>intptr_t id<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在fileapi.h文件中，定义了Windows关于文件和目录操作的API。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Unix<span class="token operator">/</span>Linux<span class="token comment">// dirent.h</span>DIR <span class="token operator">*</span> <span class="token function">opendir</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token class-name">dirent</span> <span class="token operator">*</span> <span class="token function">readdir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">closedir</span><span class="token punctuation">(</span>DIR <span class="token operator">*</span>dirp<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>OGRE的文件系统 在OGRE中，对于Win32平台，使用的是dirent.h和io.h中提供的函数_findfirst、_findnext、_findclose。 对于Unix/Linux平台，则通过dirent.h中的opendir、readdir、closedir实现了上面3个函数。</p><h4 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h4><p>应用程序对于窗口的操作，主要集中在创建、删除窗口，查询、设置属性等。除此之外，还要管理绘图上下文。 与窗口相关的还有窗口的事件处理，如何让使用者也能接收到事件也是必须要考虑的问题。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Win32<span class="token comment">// windows.h</span><span class="token comment">// 注册窗口类</span>WNDCLASS wndClass<span class="token punctuation">;</span><span class="token function">RegisterClass</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>wndclass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//创建窗口</span>HWND hwnd <span class="token operator">=</span> <span class="token function">CreateWindow</span><span class="token punctuation">(</span><span class="token string">"WndClassName"</span><span class="token punctuation">,</span> <span class="token string">"WindowName"</span><span class="token punctuation">,</span> WS_OVERLAPPEDWINDOW<span class="token punctuation">,</span> CW_USEDEFAULT<span class="token punctuation">,</span> CW_USEDEFAULT<span class="token punctuation">,</span> CW_USEDEFAULT<span class="token punctuation">,</span> CW_USEDEFAULT<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> hInstance<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 显示（隐藏）窗口</span><span class="token function">ShowWindow</span><span class="token punctuation">(</span>hwnd<span class="token punctuation">,</span> SW_SHOW<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ShowWindow(hwnd, SW_HIDE);</span><span class="token comment">// 获取窗口尺寸</span><span class="token function">GetWindowRect</span><span class="token punctuation">(</span>hwnd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rect<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 获取客户区域尺寸</span><span class="token function">GetClientRect</span><span class="token punctuation">(</span>hwnd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rect<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Linux 关于Linux上的窗口系统，可以参考《关于X11》这篇文章。<br>Linux相关<em><a href="https://juejin.cn/post/7006357005954711588">https://juejin.cn/post/7006357005954711588</a><br><a href="https://blog.csdn.net/weixin_43833642/article/details/105341872">https://blog.csdn.net/weixin_43833642/article/details/105341872</a><br><a href="https://blog.csdn.net/tq384998430/article/details/100707619">https://blog.csdn.net/tq384998430/article/details/100707619</a></em></p><h4 id="设备IO"><a href="#设备IO" class="headerlink" title="设备IO"></a>设备IO</h4><p>对于大部分应用程序而言，其输出设备主要是显示器、音箱（或耳机），输入设备则种类较多：键盘、鼠标、游戏杆、游戏手柄、摄像头、麦克风等。一个典型的跨平台的人机接口函数库如OIS（Object Oriented Input System，面向对象输入系统）。</p><h4 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h4><p>在使用特定语言具体实现一个平台独立层，有很多细节部分需要考虑。</p><p>函数返回值</p><p>参考Win32的API设计，可以发现大部分函数都用HRESULT作为返回值类型，并且定义了若干个宏来表示函数运行状态。如:</p><p>S_OK代表运行正常，</p><p>E_FAIL代表未知错误，</p><p>E_OUTOFMEMORY代表内存不足，</p><p>E_INVALIDARG代表非法参数。 </p><p>在winerror.h中有HRESULT与相关错误代码的定义，HRESULT本质上是一个4字节值，所以我们在非Win32平台下，可以定义自己的HRESULT类型。</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>_WIN32<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>PLATFORM_HRESULT_DEFINE<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>    <span class="token expression"><span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>_HRESULT_DEFINED<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>__midl<span class="token punctuation">)</span></span></span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PLATFORM_HRESULT_DEFINE</span></span><span class="token comment">// 定义4字节整形</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> int32<span class="token punctuation">;</span><span class="token comment">// 定义 HRESULT 类型</span><span class="token keyword">typedef</span> <span class="token keyword">long</span> HRESULT<span class="token punctuation">;</span><span class="token comment">/*  还可以参照winerror.h定义一些工具宏，以及常用错误代码  如  MAKE_HRESULT      SUCCEEDED      FAILED*/</span><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>指针的处理</p><p>当一个封装好的库需要向使用者提供指针的时候，必须得考虑指针所指对象的生命周期的管理。 一个简单的办法是使用智能指针，在最新的C++11中，已包括了智能指针，其他也有很多库都提供了智能指针的实现，比如Boost。 另一个办法是定义一套使用规则，保证通过Create返回的指针，使用完之后，必须调用Release，即手动管理生命周期。</p><h3 id="三、核心系统"><a href="#三、核心系统" class="headerlink" title="三、核心系统"></a>三、核心系统</h3><p>断言：gsl::assert</p><p><a href="https://github.com/Microsoft/GSL">Guidelines Support Library</a>是C++官方的辅助库，有Expects和Ensures分别检测pre-condition和post-condition。是assert的更好替代，推荐使用。</p><p>单元测试：boost::test。</p><p>内存分配：c++默认分配器</p><p>注意我们没有使用高性能的tbb、tcmalloc等分配器。原因有两点：</p><p>减少依赖。依赖第三方内存分配器，容易引入更多的bug，使得程序更难调试，我们不太希望有意外的惊喜。性能对我们这种没人用的引擎，没有那么重要，哈哈哈。<br>内存预分配。我们会尽量预先分配好内存，这样分配器性能就没有那么重要了。</p><p>数学库：<a href="http://eigen.tuxfamily.org/index.php?title=Main_Page">eigen</a><a href="https://zhuanlan.zhihu.com/p/87598519">简单介绍</a></p><p>eigen是一款非常好的跨平台数学库，无论是易用性、工程性、性能、功能、扩展能力、跨平台性都是顶尖的。被广泛运用到PCL、OpenCV、Meshlab等优秀的类库中，是久经考验的一款数学库。eigen是我们的核心依赖，会用到Dense、Geometry、Spline等功能。</p><p>字符串与散列字符串标识符：</p><p>std::string，std::string_view，boost::algorithm::string，boost::flyweight</p><p>std::string虽然饱受诟病，不过配合boost::algorithm还是可以一战的。flyweight能方便的制作string的handle，减少内存分配，有跨dll能力，也许会用到。</p><p>调试用打印和日志：boost::log</p><p>这里的问题是boost::log必须启用rtti，但引擎的runtime又不会开启rtti，所以就暂时就不打log了。这里就体现c++为什么需要zero-overhead abstraction了，功能有传染性的话，那就只有不用了。</p><p>本地化服务：std::locale，std::codecvt</p><p>c++的locale和codecvt是两朵巨大的奇葩，标准变了又变，我现在已经混乱了。等c++20引入了char8_t再说吧，先不解决locale问题了。</p><p>引擎配置：boost::property_tree，boost::program_option</p><p>一个读写配置、一个读写控制行命令，很省事。现在用的不多。</p><p>随机数生成器：std::random，boost::random</p><p>都可以用，速度一般。</p><p>曲线与曲面库：unsupported.Eigen.Spline</p><p>对象句柄/唯一标识符：boost::uuid</p><p>uuid就是一般的guid，我们的资源索引基本会用uuid描述。资源模块之后的章节会介绍。</p><p>异步文件io：std::filesystem，std::iostream，boost::asio</p><p>这三个加起来，可以解决异步文件io的问题，就是需要一点开发。</p><p>场景图/剔除优化</p><p>空间剖分：boost::geometry::index::rtree</p><p>空间索引，暂时不用开发octree/bvh，不用开发的功能就是好的功能！</p><p>以上这些模块，官方文档又全又好。</p><p>平台独立层和核心系统是不需要开发的，削减了一小半的工作量。这让我们可以把精力集中到资源和渲染器上。</p><h3 id="代码编译"><a href="#代码编译" class="headerlink" title="*代码编译"></a>*代码编译</h3><h4 id="vcpkg"><a href="#vcpkg" class="headerlink" title="vcpkg"></a><a href="https://github.com/Microsoft/vcpkg">vcpkg</a></h4><p><a href="https://zhuanlan.zhihu.com/p/88956340">https://zhuanlan.zhihu.com/p/88956340</a></p><h4 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h4><h3 id="四、资源管理系统"><a href="#四、资源管理系统" class="headerlink" title="四、资源管理系统"></a>四、资源管理系统</h3><h3 id="五、主要功能系统"><a href="#五、主要功能系统" class="headerlink" title="五、主要功能系统"></a>五、主要功能系统</h3><h4 id="低阶渲染器"><a href="#低阶渲染器" class="headerlink" title="低阶渲染器"></a>低阶渲染器</h4><h4 id="场景图与剔除优化"><a href="#场景图与剔除优化" class="headerlink" title="场景图与剔除优化"></a>场景图与剔除优化</h4><h4 id="x2F-后期效果"><a href="#x2F-后期效果" class="headerlink" title="/后期效果"></a>/后期效果</h4><h4 id="碰撞与物理"><a href="#碰撞与物理" class="headerlink" title="碰撞与物理"></a>碰撞与物理</h4><h4 id="骨骼动画"><a href="#骨骼动画" class="headerlink" title="骨骼动画"></a>骨骼动画</h4><h3 id="六、前端与工具链"><a href="#六、前端与工具链" class="headerlink" title="六、前端与工具链"></a>六、前端与工具链</h3><p><br><br></p><hr><p><em>参考资料</em></p><p><em>《游戏引擎架构》</em></p><p><em>《游戏引擎原理与应用》</em></p><p><em>《数字图像处理第四版》</em></p><p><em><a href="https://www.bilibili.com/video/BV1X7411F744/?vd_source=b0edc91d595b72577053303a4da8a361">GAMES101-现代计算机图形学入门-闫令琪</a><br><a href="https://www.notion.so/GAMES101-b0e27c856cde429b8672671a54c34817">GAMEs101笔记</a></em></p><p><em><a href="https://www.bilibili.com/video/BV1oU4y1R7Km/">GAMES104-现代游戏引擎：从入门到实践</a><br><a href="https://www.zhihu.com/people/whys0far/columns">104笔记</a></em></p><p><em><a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2">https://www.youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2</a><br><a href="https://www.youtube.com/playlist?list=PLlrATfBNZ98dC-V-N3m0Go4deliWHPFwT">https://www.youtube.com/playlist?list=PLlrATfBNZ98dC-V-N3m0Go4deliWHPFwT</a><br><a href="https://www.zhihu.com/column/starengine">https://www.zhihu.com/column/starengine</a><br><a href="https://zhuanlan.zhihu.com/p/30538626">https://zhuanlan.zhihu.com/p/30538626</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 游戏引擎 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ayana引擎开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随笔与牢骚与乱七八糟的合集/发癫日记</title>
      <link href="/2023/02/05/sui-bi-yu-lao-sao-he-luan-qi-ba-zao-de-he-ji/"/>
      <url>/2023/02/05/sui-bi-yu-lao-sao-he-luan-qi-ba-zao-de-he-ji/</url>
      
        <content type="html"><![CDATA[<p>………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….</p><p><code>warning!警告!</code></p><p><code>以下内容将毫无营养</code></p><hr><hr><hr><h2 id="以下是手机的笔记，时间线上在大一到大二"><a href="#以下是手机的笔记，时间线上在大一到大二" class="headerlink" title="以下是手机的笔记，时间线上在大一到大二"></a>以下是手机的笔记，时间线上在大一到大二</h2><p>稍微整理分类以后如下</p><h3 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h3><p>小提琴有一种孤怆的美感，像“喑哑的嘶鸣”</p><p>一长声小提琴加两声清脆的钢琴，从屋檐滑落的雨滴洒在地板上溅开，和缓缓飘落的枫叶落在路上被行人踏碎的感觉</p><p>钢琴的如雨般宁静，不同吉他平静中悠闲，而有很强的归属与抚平一切的温柔，即便再奔放的表达，也有一种含蓄的优雅在。</p><hr><p>我心中的音乐是真诚而炽热感情的表达，即使是摇滚和说唱也类，也不应该是所谓高歌人的恶混沌和黑暗的东西。</p><p>我个人来说一直不是特别喜欢鼓点特别大或是节奏特别快的的音乐。但是因为beyond的爱上摇滚，因为周杰伦爱上说唱。我才发现。摇滚和说唱，在有些个别的艺术家的手中已经被曲解了。真正的摇滚和说唱是什么？</p><p>摇滚是革命，改革自我，改革命运，告别懦弱和退让，而且，不是在言语上，是在艺术里。风雨中绝不熄灭的烛火，岩洞下永远沸腾的岩浆……无人可挡，无法停止的气魄，这才是我的摇滚。</p><h3 id="发癫"><a href="#发癫" class="headerlink" title="发癫"></a>发癫</h3><p>想到未来，想到死亡，以及迄今为止废物的二十年……</p><p>魔幻又泛着恶臭油腥味儿的世界，我寥寥无几的重要的人……</p><p>对自己死亡倒是很释然，对爱着的人的离去无法抑制又无力的悲伤……</p><p>不管什么死亡赋予生命意义，可是当相处很久的人突然离去，还是会伤心……</p><p>有时候豁达到什么都无所谓，有时候又会因为很小的事情在头脑里放大……</p><h3 id="赛博朋克与美"><a href="#赛博朋克与美" class="headerlink" title="赛博朋克与美"></a>赛博朋克与美</h3><p>赛博朋克边缘行者<br>年龄大了越来越接受不了赛博朋克和黑深残这类的设定了，反而是之前略觉寡淡的日常系更对我胃口，而且越来越喜欢校园感，单纯的日常……</p><p>而且更喜欢纯粹表达的美感……</p><p>初高中是喜欢看科幻，或者是赛博风格题材的什么黑深残，阴谋论，恰好满足那个年龄寻求的感官刺激，狂妄的想象和自认的成熟。不过现在对一个大学生来说或许过于刺激了=_=</p><p>今天下午课前我提议说再走一次时常无人的小道，半开玩笑的讲，再回味一下桂花香，秋冬冷日中的余香像是因为某种不可抗力而被迫断裂的爱情，在她回头，即将离开迈出第一步之前飘扬发丝尾端的余味。恰是“孔雀东南飞，五里一徘徊”。</p><p>为什么，感觉自己越来越理想主义了</p><p>这种单纯的美感emm……</p><p>“你这都是电影里的，现在都是晚上QQ一删，翌日相遇就是路人”</p><p>这是现实。</p><p>如果被迫在影视作品中还要被迫面对现实，反正我不接受。好在这部作品结尾仍然是浪漫的，恰是因为在不允许信任的世界里，心与心的联结才更加浪漫。</p><p>这种设定之下就注定是悲剧，是末世废土中开出的白百合，或者说，是喧嚣的血液和肢节满天横飞，无尽奏响着的飞扬进行曲时，在世界的中心，是纯白的旧建筑里薰嗣的简单钢琴声与旁边单一棵翠绿的树的共鸣……</p><p>另外感觉这番好浓的EVA味，之前刚看的斩服少女也是，不愧是扳机社。另外这部作品本身一定是一部好作品，不然我也不会意难平在这里逼逼叨叨了，瞎扯一通了。</p><p>最后，</p><p>“老板！点歌！《FLY ME TO THE MOON》！”</p><h3 id="然后在这里插一个高考前的文章"><a href="#然后在这里插一个高考前的文章" class="headerlink" title="然后在这里插一个高考前的文章"></a>然后在这里插一个高考前的文章</h3><br><font size="4">《水到渠成》</font><br><br><p>我的前面是一望无际的弯曲的路</p><p>我的后面是一望无际的弯曲的路</p><p>我的两边是喘着热气的、无尽的灰土</p><p>全是裂痕，全是裂痕</p><p>浮着奇异的波纹</p><p>————我的头上是死死的太阳</p><br><p>“顶住那车！”</p><p>从远方而来，里面是我所有的一切</p><p>我所有的爱、我所有的智慧</p><p>“我不能后退！！”</p><br><p>车轮轧碎了我的前脚掌</p><p>在路上流下两条殷红的平行线</p><p>我的胳膊已经折断</p><p>我的脊骨正在变形</p><p>我大叫，喉咙里往外翻血</p><p>蚊子般的长鸣</p><p>我拼命地让身体立着</p><p>青蓝泛紫的金属机壳进入右臂，进入肺，进入心脏……</p><p>身体就染红了</p><p>是多么自然而然的事情</p><p>我有些害怕，有些犹豫</p><p>我终于选择了逃避</p><br><p>我瘫坐在灰土地上</p><p>望着那辆车</p><p>沿着蛇一样的路</p><p>慢慢地，慢慢地，走过了许多时间</p><br><p>我拖着扭曲后无用的身体</p><p>像蛇一样地爬</p><p>无可奈何，也没有办法</p><br><p>扭曲无用的身体……</p><p>水分也慢慢蒸发</p><p>到空气里，再也找不见了</p><p>我终于也成了土地</p><br><h2 id="02-x2F-05"><a href="#02-x2F-05" class="headerlink" title="02/05"></a>02/05</h2><p>什么都没有发生，无聊的一天捏，虽说是元宵节但是真无聊</p><p>晚上吃饭的中年大叔指点江山环节，各种大学的任何专业都能评判的头头是道</p><p>我一个人缩在角落玩手机就是了</p><p>等以后工作了这种亲戚饭局一定能推就推，奶奶滴</p><p>离开这河南，再也不回来了……</p><h2 id="02-x2F-07"><a href="#02-x2F-07" class="headerlink" title="02/07"></a>02/07</h2><p>其实你主要是想的太多而做的太少了</p><p>好好弄一下绩点与基本功，四大件就是了</p><h2 id="02-x2F-08"><a href="#02-x2F-08" class="headerlink" title="02/08"></a>02/08</h2><p>我要被飘着油的水塘淹死了</p><p>不是被水淹死的</p><p>而是上面泛着的油光</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机图形学</title>
      <link href="/2023/02/05/ru-he-xue-xi-ji-suan-ji-tu-xing-xue/"/>
      <url>/2023/02/05/ru-he-xue-xi-ji-suan-ji-tu-xing-xue/</url>
      
        <content type="html"><![CDATA[<h3 id="02-x2F-08-转一篇看到的文章"><a href="#02-x2F-08-转一篇看到的文章" class="headerlink" title="02/08 转一篇看到的文章"></a>02/08 转一篇看到的文章</h3><p>虽然困难、艰辛、回报周期长，但是总有我辈乐此不疲。图形学的快乐是非常直接的，因为所见即所得，即便对HPC的极至优化已经十分偏向底层而且抽象，但实时性fps的体现都是直接的，更何况是做算法或者应用呢？社区很小、圈子里同行几乎5位数可以遍历（学术界哈），但是很高兴看到即使贵为ACM SIGGRAPH高高在上，也为拥抱新来者可以做出改变。</p><p>首先，这个圈子你几乎只会看到完全interest-driven的人，毕竟想卷可以去cv和dl卷，想挣钱直接互联网大厂，所以留下来的都是以graphic is awesome 为信仰的人。</p><p>其次，未来大有可期，毕竟虚拟现实单单这一个应用前景就可以推动计算机系统结构、图形学实时渲染与仿真再拥抱一个黄金时代（头号玩家、黑客帝国中的构想还远远未到来）。</p><p>而且，图形学在智能医疗、智慧工业等前瞻性的项目中都大有作为，可以说是数字化浪潮底层之中的一道地基（毕竟graphic面对的是将抽象几何表示变为各种媒介视觉产物这一基础而且必备的需求，这种必备性源于视觉是五感中获取信息最高效的感官这一生理基础）。</p><p>更加现实一点的话，面向就业需求，游戏产业、科技公司都有对口的岗位，而且国内面向图形起家的科技公司越来越多（动画仿真这边听闻的例如胡渊鸣、张心欣、王华民等前辈所在的科技公司，另华为也有项目和组里合作，阿里、腾讯似乎在招工程师和研究员）。国外目前机会更多一些。</p><p>最后呢，想要入坑图形，除了cs科班的基本素养，还要至少坐一年的冷板凳，精进c++，学习opengl、vulkan等API，学习现代图形学的基本理论知识，以及修补以前没学好的数学。游戏引擎或者建模软件动画软件这种上层建筑同步学习就好。再然后，就可以愉快地刷大部头经典教材以及自己写渲染器或者物理模拟引擎了。这些都走一遍一年远远不够，也许需要几年，但是一年来说入门还是可以的。</p><p>未来可期，如果仔细叩问自己仍然觉得心向往之，具有极强的内驱力，那么欢迎加入图形学大家庭鸭！</p><p>国内GAMES平台：<a href="https://games-cn.org/">https://games-cn.org/</a></p><p>国外ACM等</p><p>作者：羽扇轻摇</p><p>链接：<a href="https://www.zhihu.com/question/518502089/answer/2369923604">https://www.zhihu.com/question/518502089/answer/2369923604</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者是从游戏引擎第一次接触计算机图形学，所以更多的是偏渲染向的，特别是实时渲染。这里存一些学习路径或者学习资料，教程网站之类的东西。</p><p>图形学作为程序员三大浪漫，（另外两个是编译原理和操作系统，虽然有有人说加上网络hhh），但我觉得图形学和网络是最浪漫的cs方向<span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>好像能看到但目标又好像那么遥远，有一种爱而不得的美。</p><p>上面是开玩笑的，但是很多图形学的算法确实是很美妙~<span class="github-emoji"><span>😇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f607.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="什么是计算机图形学"><a href="#什么是计算机图形学" class="headerlink" title="什么是计算机图形学"></a><a href="http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm">什么是计算机图形学</a></h2><p><a href="http://staff.ustc.edu.cn/~lgliu">刘利刚</a></p><p>简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。</p><p>实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别并不非常清晰，很多都是相通的。</p><p>笔者觉得学习一门知识，一个研究方向，就好比在沙地上挖坑。随着本方向的领域研究越发深入，其相关的知识与技能需求也会逐步的跟进并且范围会越来越大。在知识的领域，真的只集中一点往往并不能登封造极。</p><hr><h2 id="如何学习计算机图形学"><a href="#如何学习计算机图形学" class="headerlink" title="如何学习计算机图形学"></a><a href="http://staff.ustc.edu.cn/~lgliu/Resources/CG/How_to_Learn_CG&amp;Coding.htm">如何学习计算机图形学</a></h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>数学知识，如线性代数、三维几何学、微积分等。<br>数学在图形学中的应用，透视投影、光线追踪、景深模拟等</p><h3 id="编程语言，基础的数据结构与算法"><a href="#编程语言，基础的数据结构与算法" class="headerlink" title="编程语言，基础的数据结构与算法"></a>编程语言，基础的数据结构与算法</h3><p>编程语言，如C++、Python等。<br>编程语言的高级特性，模板、多线程、编译器优化等。</p><h3 id="图形学基础"><a href="#图形学基础" class="headerlink" title="图形学基础"></a>图形学基础</h3><p>图形学基本概念，如渲染算法、光照模型、几何学等。<br>图形学基本流程，例如对三维模型的投影、照明、深度测试等。</p><h3 id="图形学工具"><a href="#图形学工具" class="headerlink" title="图形学工具"></a>图形学工具</h3><p>熟悉常用的图形学工具，如OpenGL、DirectX等。<br>了解图形学工具的特点，支持的渲染模型、硬件加速等。</p><h3 id="图形学算法"><a href="#图形学算法" class="headerlink" title="图形学算法"></a>图形学算法</h3><p>了解常用算法，光线追踪、景深模拟、半透明合并等。<br>学会使用图形学算法解决问题，例如模拟自然环境、动态角色行为等。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>不断学习计算机图形学领域的最新技术，保持对技术的敏感和兴趣。</p><p>通过阅读技术文章、或技术会议等方式，了解最新发展方向和应用。</p><p>通过实际项目的开发积累实践经验，制作游戏等。<br>利用实践经验检验自己的技能，不断提高自己的专业水平。</p><p>与同行交流互相学习，增加对图形学的理解。<br>在团队合作的过程中，学习如何协作解决复杂的问题。</p><h2 id="资料整理"><a href="#资料整理" class="headerlink" title="资料整理"></a>资料整理</h2><ol><li>-大学图形学课程的课本是Donald Hearn的Computer Graphics第四版<br><img src="https://tudingtu.cn/i/2023/02/05/11au0iv.jpg" alt="Computer Graphics"></li></ol><p>-实时渲染那本，但是好像没有官方汉化emmm</p><p>2.<a href="http://www.kevinbeason.com/smallpt/">实现基于Path Tracing的光线追踪渲染器</a></p><p>3.软渲染</p><p><a href="http://www.3dcpptutorials.sk/index.php?id=15">3D C/C++ tutorials - Software rendering</a></p><p><a href="https://trenki2.github.io/blog/2017/06/06/developing-a-software-renderer-part1">Developing a Software Renderer Part 1</a></p><p>4.opengl(虽然很老了，但确实经典)</p><p><a href="https://learnopengl-cn.github.io/#">opengl文档</a></p><p><a href="https://www.youtube.com/@TheCherno/playlists">cherno大佬</a>&lt;–强烈推荐</p><p>MRSA联合实验室：浙大，清华，哈工大，港大，中科，北大，港中文，上交，北电，西交。</p>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图形学杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作与考研的二三事</title>
      <link href="/2023/02/05/gong-zuo-yu-kao-yan/"/>
      <url>/2023/02/05/gong-zuo-yu-kao-yan/</url>
      
        <content type="html"><![CDATA[<br><h3 id="23-x2F-02-x2F-07与父母交流结果"><a href="#23-x2F-02-x2F-07与父母交流结果" class="headerlink" title="23/02/07与父母交流结果"></a>23/02/07与父母交流结果</h3><p>以下是交流后有感发的推文转载：</p><blockquote><p>我妈妈虽然平时还蛮尊重我的，但是今晚聊到了工作和考研的话题。我能很明显的感受到我妈就是想让我考研。她那一大推话总结一下就是，<br><br>1，考研以后社会地位高。<br><br>2，工作薪资待遇更高，提拔更快。<br><br>我能感受到.在她心里面，还是刻板地觉得研究生多么稀有 ，工作与学历是正比的巴拉巴拉。1/n</p></blockquote><blockquote><p>长辈总是会用他们的年龄来论证他们的观点……要么无限重复，要么辈分压制<br><br>甚至我不好说是否因为孩子是研究生他们更方便他们回村吹牛逼……<br><br>以下均为大二的大学生的看法，可能和一些实习，工作者或研究生偶尔交流，再往上一点的信息就大部分来源网络.<br><br>对于薪资，我感觉有，但是关系并没有他们想象的那么大。IT行业还是以技术为主.2/n</p></blockquote><blockquote><p>首先我觉得，真正掌握的技术以及能直接证明能力的证书，项目等才是最有力的。<br><br>其次，工作不意味着不学习。根据咱了解的，如果进入的是比较好的团队，甚至工作以后的学习会比在学校更多更复杂，当亲手参加工程时的经验和知识，有可能更加宝贵，</p></blockquote><blockquote><p><font size="3">总结</font><br><br>综合现在我能接触到的信息，目标是尽可能收益最大化。大二的我，现在安排的事就是，学基础的四大件，对有兴趣的方向自己可以研究，（当然课内正常就好了）。除此以外可以稍微留意一些行业信息什么的</p></blockquote><blockquote><p>想法是哪里合适就去哪里，具体问题具体分析<br>我也只是想表达出，选择考研和选择工作，只是不同的选择，并没有高低贵贱之分，拿来吹牛逼大可不必~</p></blockquote><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="https://zhuanlan.zhihu.com/p/26767172">工作相比考研的优势</a></p><p><a href="https://zhuanlan.zhihu.com/p/100039030">相关数据</a></p><h3 id="一些图片"><a href="#一些图片" class="headerlink" title="一些图片"></a>一些图片</h3><p><img src="https://i.postimg.cc/Z5g3RTFy/v2-99e0bf3992b7353b7b63d34e56492456-r.jpg" alt="计算机类的三年工作经验薪水涨幅99%"></p><p><img src="https://i.postimg.cc/6QcXcQj8/v2-a91698bb6c62a09a22b9edbffc205c17-r.jpg" alt="互联网与软件硕本薪水涨幅约40%"></p><p>当然数据并不能说明具体的问题，一切还是得从自己的情况出发，选择适合自己的路走。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tuple用法总结</title>
      <link href="/2023/02/05/tuple-yong-fa-zong-jie/"/>
      <url>/2023/02/05/tuple-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="tuple简介"><a href="#tuple简介" class="headerlink" title="tuple简介"></a>tuple简介</h2><p>tuple（元组）在c++11中开始引用，是一个固定大小的不同类型值的集合，是泛化的std::pair。</p><p>我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。</p><p>std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</p><h2 id="tuple的创建和初始化"><a href="#tuple的创建和初始化" class="headerlink" title="tuple的创建和初始化"></a>tuple的创建和初始化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> std::tuple&lt;T1, T2, TN&gt; t1;//创建一个空的tuple对象,它对应的元素分别是T1和T2...Tn类型，采用值初始化。std::tuple&lt;T1, T2, TN&gt; t2(v1, v2, ... TN);//创建一个tuple对象，它的两个元素分别是T1和T2 ...Tn类型; 要获取元素的值需要通过tuple的成员get&lt;Ith&gt;(obj)进行获取(Ith是指获取在tuple中的第几个元素)。std::tuple&lt;T1&amp;&gt; t3(ref&amp;); // tuple的元素类型可以是一个引用std::make_tuple(v1, v2); // 像pair一样也可以通过make_tuple进行创建一个tuple对象// tuple的元素类型为引用：std::string name;std::tuple&lt;string &amp;, int&gt; tpRef(name, 30);// 对tpRef第一个元素赋值，同时name也被赋值 - 引用std::get&lt;0&gt;(tpRef) = "Sven"; // name输出也是Svenstd::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt; '\n';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tuple的操作"><a href="#tuple的操作" class="headerlink" title="tuple的操作"></a>tuple的操作</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//1.等价结构体struct person {    char *m_name;    char *m_addr;    int  *m_ages;};//可以用tuple来表示这样的一个结构类型，作用是一样的。std::tuple&lt;const char *, const char *, int&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//2.获取tuple个数#include &lt;iostream&gt;#include &lt;tuple&gt;int main (){  std::tuple&lt;int, char, double&gt; mytuple (10, 'a', 3.14);  std::cout &lt;&lt; "mytuple has ";  std::cout &lt;&lt; std::tuple_size&lt;decltype(mytuple)&gt;::value;  std::cout &lt;&lt; " elements." &lt;&lt; '\n';  return 0;}//输出结果：mytuple has 3 elements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//3.获取元素的值#include &lt;iostream&gt;#include &lt;tuple&gt;int main (){  std::tuple&lt;int, char, double&gt; mytuple (10, 'a', 3.14);  std::cout &lt;&lt; "mytuple has ";  std::cout &lt;&lt; std::tuple_size&lt;decltype(mytuple)&gt;::value;  std::cout &lt;&lt; " elements." &lt;&lt; '\n';  //获取元素  std::cout &lt;&lt; "the elements is: ";  std::cout &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; " ";  std::cout &lt;&lt; std::get&lt;1&gt;(mytuple) &lt;&lt; " ";  std::cout &lt;&lt; std::get&lt;2&gt;(mytuple) &lt;&lt; " ";  std::cout &lt;&lt; '\n';  return 0;}/*输出结果：mytuple has 3 elements.the elements is: 10 a 3.14 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意：tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误：如：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&gt;for(int i=0; i&lt;3; i++)   std::cout &lt;&lt; std::get&lt;i&gt;(mytuple) &lt;&lt; " "; //将引发编译错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//4.获取元素的类型//要想得到元素类型可以通过tuple_element方法获取，如有以下元组对象：std::tuple&lt;std::string, int&gt; tp("Sven", 20);// 得到第二个元素类型std::tuple_element&lt;1, decltype(tp)&gt;::type ages;  // ages就为int类型 ages = std::get&lt;1&gt;(tp); std::cout &lt;&lt; "ages: " &lt;&lt; ages &lt;&lt; '\n'; //输出结果:ages: 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> //5.利用tie进行解包元素的值 //如同pair一样也是可以通过tie进行解包tuple的各个元素的值。如下tuple对象有4个元素，通过tie解将会把这4个元素的值分别赋值给tie提供的4个变量中。#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;utility&gt; int main(int argc, char **argv) {    std::tuple&lt;std::string, int, std::string, int&gt; tp;    tp = std::make_tuple("Sven", 25, "Shanghai", 21);     // 定义接收变量    std::string name;    std::string addr;    int ages;    int areaCode;     std::tie(name, ages, addr, areaCode) = tp;    std::cout &lt;&lt; "Output: " &lt;&lt; '\n';    std::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt;", ";    std::cout &lt;&lt; "addr: " &lt;&lt; addr &lt;&lt; ", ";    std::cout &lt;&lt; "ages: " &lt;&lt; ages &lt;&lt; ", ";    std::cout &lt;&lt; "areaCode: " &lt;&lt; areaCode &lt;&lt; '\n';     return 0;} /*输出结果：Output: name: Sven, addr: Shanghai, ages: 25, areaCode: 21*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但有时候tuple包含的多个元素时只需要其中的一个或两个元素，如此可以通过std::ignore进行变量占位，这样将会忽略提取对应的元素。可以修改上述例程：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;utility&gt; int main(int argc, char **argv) {    std::tuple&lt;std::string, int, std::string, int&gt; tp;    tp = std::make_tuple("Sven", 25, "Shanghai", 21);     // 定义接收变量    std::string name;    std::string addr;    int ages;    int areaCode = 110;     std::tie(name, ages, std::ignore, std::ignore) = tp;    std::cout &lt;&lt; "Output: " &lt;&lt; '\n';    std::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt;", ";    std::cout &lt;&lt; "addr: " &lt;&lt; addr &lt;&lt; ", ";    std::cout &lt;&lt; "ages: " &lt;&lt; ages &lt;&lt; ", ";    std::cout &lt;&lt; "areaCode: " &lt;&lt; areaCode &lt;&lt; '\n';     return 0;} /*输出结果：Output: name: Sven, addr: , ages: 25, areaCode: 110*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//6. tuple元素的引用//前面已经列举了将引用作为tuple的元素类型。下面通过引用搭配make_tuple()可以提取tuple的元素值，将某些变量值设给它们，并通过改变这些变量来改变tuple元素的值：#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;functional&gt; int main(int argc, char **agrv) {     std::tuple&lt;std::string, int, float&gt; tp1("Sven Cheng", 77, 66.1);     std::string name;    int weight;    float f;     auto tp2 = std::make_tuple(std::ref(name), std::ref(weight), std::ref(f)) = tp1;     std::cout &lt;&lt; "Before change: " &lt;&lt; '\n';    std::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt; ", ";    std::cout &lt;&lt; "weight: " &lt;&lt; weight &lt;&lt; ", ";    std::cout &lt;&lt; "f: " &lt;&lt; f &lt;&lt; '\n';     name = "Sven";    weight = 80;    f = 3.14; std::cout &lt;&lt; "After change: " &lt;&lt; '\n';std::cout &lt;&lt; "element 1st: " &lt;&lt; std::get&lt;0&gt;(tp2) &lt;&lt; ", ";std::cout &lt;&lt; "element 2nd: " &lt;&lt; std::get&lt;1&gt;(tp2) &lt;&lt; ", ";std::cout &lt;&lt; "element 3rd: " &lt;&lt; std::get&lt;2&gt;(tp2) &lt;&lt; '\n';     return 0;} /*输出结果：Before change: name: Sven Cheng, weight: 77, f: 66.1After change: element 1st: Sven, element 2nd: 80, element 3rd: 3.14*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector用法总结</title>
      <link href="/2023/02/01/vector-yong-fa-zong-jie/"/>
      <url>/2023/02/01/vector-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="vector相关的用法总结"><a href="#vector相关的用法总结" class="headerlink" title="vector相关的用法总结"></a>vector相关的用法总结</h2><p>因为最近经常用，于是总结在这个地方。</p><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>1.顺序序列<br>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p><p>2.动态数组<br>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。提供了在序列末尾相对快速地添加/删除元素的操作。</p><p>3.能够感知内存分配器的（Allocator-aware）<br>容器使用一个内存分配器对象来动态地处理它的存储需求。</p><hr><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>使用vector需要注意以下几点：</p><p>1.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p><p>2.Vector作为函数的参数或者返回值时，需要注意它的写法：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b); //其中的“&amp;”不能少<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.vector的元素不仅仅可以是int,double,string,还，可以是结构体，但是要注意：结构体要定义为全局的.</p><h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><p>使用：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;vector&gt;vector&lt;int&gt; vec;///建立一个vector，int为数组元素的数据类型，vec为动态数组名vector&lt;vector&lt;long int&gt; &gt; vec2; //定义一个二维数组vec2vec.push_back(1);vec.push_back(2);//把1和2压入vector，这样vec[0]就是1,vec[1]就是2cout&lt;&lt;vec[0]&lt;&lt;endl;//使用下标访问元素//使用迭代器访问元素.vector&lt;int&gt;::iterator it;for(it=vec.begin();it!=vec.end();it++)    cout&lt;&lt;*it&lt;&lt;endl;vec.insert(vec.begin()+i,a);//插入,在第i+1个元素前面插入avec.erase(vec.begin()+2);//删除元素,删除第3个元素vec.erase(vec.begin()+i,vec.end()+j);//删除区间[i,j-1];区间从0开始vec.size();//向量大小vec.clear();//清空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些算法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithm&gt;reverse(vec.begin(),vec.end());//将元素翻转，即逆序排列sort(vec.begin(),vec.end());//默认升序排列//降序排列需重写bool Comp(const int &amp;a,const int &amp;b){    return a&gt;b;}sort(vec.begin(),vec.end(),Comp)//降序排序//交换两个同类型向量的数据vector&lt;int&gt;vec2;swap(vec,vec2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先这样，之后用到了再加叭qaq <span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>~</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——4.形容词，形容动词</title>
      <link href="/2023/01/28/ri-yu-yu-fa-4-xing-rong-ci-xing-rong-dong-ci/"/>
      <url>/2023/01/28/ri-yu-yu-fa-4-xing-rong-ci-xing-rong-dong-ci/</url>
      
        <content type="html"><![CDATA[<h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><p>空は青い。<br>空は青いです。//更礼貌<br>天空是蓝色的。</p><p><em>形容词可以直接做谓语后不需加だ，做终止形</em></p><p>青い空。<br>蓝色的天空。</p><p><em>形容词做定语，直接加名词，不加の，做连体形</em><br><em>名词代词等即体言</em></p><h3 id="形容动词"><a href="#形容动词" class="headerlink" title="形容动词"></a>形容动词</h3><p><em>形容动词的变化方式和动词相同</em></p><p>教室は静かだ。<br>教室は静かです。<br>教室安静。</p><p>静かな教室。<br>安静的教室</p><p><em>だ变な由终止形变连体形</em></p><h3 id="く-x2F-で"><a href="#く-x2F-で" class="headerlink" title="~く/で"></a>~く/で</h3><p><em>形容词，形容动词，与动词称为用言</em><br><em>同理，连接用眼的部分即为连用形</em></p><p>教室は大きく、静かだ。<br>教室很大也很安静。</p><p><em>形容词い变く，变连用形</em></p><p>教室は静かで、大きい。<br>教室很安静也很大。</p><p><em>形容动词以で结尾，变连用形，和名词相同</em></p><h3 id="ない"><a href="#ない" class="headerlink" title="~ない"></a>~ない</h3><p>この本は面白くない。<br>この本は面白くないです。//敬<br>この本は面白くありません。//敬<br>这本书没意思。</p><p><em>因为后要加ない这个补助形容词,面白い变面白く，即变为连用形</em></p><p>あの俳優さんは有名ではない。<br>あの俳優さんは有名ではありません。<br>那个演员没有名气。</p><h3 id="かつた-x2F"><a href="#かつた-x2F" class="headerlink" title="~かつた/"></a>~かつた/</h3><p><em>连用形的过去式</em></p><p>昨日は寒かっだ。<br>昨日は寒かっだです。<br>昨天冷。</p><p>昨日は寒くなかっだ。<br>昨日は寒くなかっだです。<br>昨日は寒くありませんでした。//でした表过去<br>昨天不冷。</p><p>寒<del>い</del><br>　く＋な<del>い</del><br>　　　　かっだ</p><p><em>为了加ない、寒い变寒く</em><br><em>然后把ない变~かっだ、即过去式的连用形</em></p><h3 id="だった"><a href="#だった" class="headerlink" title="~だった"></a>~だった</h3><p>私はもともと学生だった//だ变だった表过去<br>私はもともと学生でした。//更礼貌<br>我原本是个学生。</p><p>昨日教室は静かだった。<br>昨日教室は静かでした。<br>昨天教室安静。</p><p>昨日教室は静かではなかっだ。<br>昨日教室は静かではありませんでした。<br>昨天教室不安静。</p><h3 id="连体词"><a href="#连体词" class="headerlink" title="连体词"></a>连体词</h3><p><em>只能连接体言的词语</em></p><p>大きな<br>大的</p><p>小さな<br>小的</p><p>色んな<br>各式各样的</p><p><em>上面三个只有连体词一种词性</em></p><p>同じ<br>一样的<br><em>而同じ还是个形容动词，同じだ/です等</em></p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——3.人称代词</title>
      <link href="/2023/01/25/ri-yu-yu-fa-3-ren-cheng-dai-ci/"/>
      <url>/2023/01/25/ri-yu-yu-fa-3-ren-cheng-dai-ci/</url>
      
        <content type="html"><![CDATA[<h3 id="一人称"><a href="#一人称" class="headerlink" title="一人称"></a>一人称</h3><table><thead><tr><th align="center">私（わたし）</th><th align="center">日常女性使用，正式场合男女通用</th></tr></thead><tbody><tr><td align="center">私（わたくし）</td><td align="center">男女通用，正式场合</td></tr><tr><td align="center">僕</td><td align="center">男，非正式</td></tr><tr><td align="center">俺</td><td align="center">男，粗鲁</td></tr><tr><td align="center">俺様</td><td align="center">男，居高临下，十分粗鲁</td></tr><tr><td align="center">あたし</td><td align="center">女性，随意，日常</td></tr><tr><td align="center">うち</td><td align="center">女性</td></tr></tbody></table><h3 id="二人称"><a href="#二人称" class="headerlink" title="二人称"></a>二人称</h3><h4 id="不知道对方姓名时："><a href="#不知道对方姓名时：" class="headerlink" title="不知道对方姓名时："></a>不知道对方姓名时：</h4><table><thead><tr><th align="center">あなた</th><th align="center">最常用，对平辈与晚辈使用，</th></tr></thead><tbody><tr><td align="center">君</td><td align="center">男性对同辈与晚辈使用</td></tr><tr><td align="center">お前</td><td align="center">男性对同辈与晚辈使用</td></tr><tr><td align="center">あんた</td><td align="center">比あなた更随意</td></tr><tr><td align="center">僕</td><td align="center">对不认识的小孩</td></tr></tbody></table><h4 id="知道对方姓名后，更礼貌的用语："><a href="#知道对方姓名后，更礼貌的用语：" class="headerlink" title="知道对方姓名后，更礼貌的用语："></a>知道对方姓名后，更礼貌的用语：</h4><h5 id="様-x2F-ちん-x2F-君-x2F-ちやん-x2F-殿（どの）-x2F-氏（し）"><a href="#様-x2F-ちん-x2F-君-x2F-ちやん-x2F-殿（どの）-x2F-氏（し）" class="headerlink" title="~様/~ちん/君/ちやん/殿（どの）/氏（し）"></a>~様/~ちん/君/ちやん/殿（どの）/氏（し）</h5><table><thead><tr><th align="center">佐藤様</th><th align="center">广泛，较礼貌，店家对客人等</th></tr></thead><tbody><tr><td align="center">佐藤さん</td><td align="center">日常</td></tr><tr><td align="center">佐藤君</td><td align="center">对同辈和晚辈，日常男性使用</td></tr><tr><td align="center">佐藤ちやん</td><td align="center">比较亲密</td></tr><tr><td align="center">営業部長殿</td><td align="center">前加职务，正式公文</td></tr><tr><td align="center">佐藤氏</td><td align="center">前加姓</td></tr><tr><td align="center">佐藤</td><td align="center">直呼，很亲密，或上对下，或对外人说自己人时</td></tr></tbody></table><h3 id="三人称"><a href="#三人称" class="headerlink" title="三人称"></a>三人称</h3><h4 id="人物："><a href="#人物：" class="headerlink" title="人物："></a>人物：</h4><table><thead><tr><th align="center">彼（かれ）</th><th align="center">他</th></tr></thead><tbody><tr><td align="center">彼女（かのじお）</td><td align="center">她</td></tr><tr><td align="center">こ/そ/あいつ</td><td align="center">它，家伙</td></tr></tbody></table><h4 id="物体："><a href="#物体：" class="headerlink" title="物体："></a>物体：</h4><p>こ/そ/あ/どれ       </p><hr><h3 id="复数表现"><a href="#复数表现" class="headerlink" title="复数表现"></a>复数表现</h3><table><thead><tr><th align="center">私（わたし）たち</th><th align="center">最常用，相当于“们”</th></tr></thead><tbody><tr><td align="center">あなたがだ</td><td align="center">较礼貌</td></tr><tr><td align="center">彼ら</td><td align="center">较不礼貌 <em>只有彼没有彼だち的用法</em></td></tr><tr><td align="center">私（わたくし）ども</td><td align="center">最礼貌，自谦语</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——2.指示代词</title>
      <link href="/2023/01/25/ri-yu-yu-fa-2-zhi-shi-dai-ci/"/>
      <url>/2023/01/25/ri-yu-yu-fa-2-zhi-shi-dai-ci/</url>
      
        <content type="html"><![CDATA[<h3 id="こ-指离说话人近的事物-x2F-近"><a href="#こ-指离说话人近的事物-x2F-近" class="headerlink" title="こ　指离说话人近的事物/近"></a>こ　指离说话人近的事物/近</h3><h3 id="そ-指离听话人近的事物-x2F-稍远"><a href="#そ-指离听话人近的事物-x2F-稍远" class="headerlink" title="そ　指离听话人近的事物/稍远"></a>そ　指离听话人近的事物/稍远</h3><h3 id="あ-指离双方都远的事物-x2F-很远"><a href="#あ-指离双方都远的事物-x2F-很远" class="headerlink" title="あ　指离双方都远的事物/很远"></a>あ　指离双方都远的事物/很远</h3><h3 id="ど-不定"><a href="#ど-不定" class="headerlink" title="ど　不定"></a>ど　不定</h3><hr><h3 id="れ、-の、-の"><a href="#れ、-の、-の" class="headerlink" title="~れ、~の、~の~"></a>~れ、~の、~の~</h3><p>これは本だ<br>这是书</p><p>この本は私の（本）だ<br>这本书是我的</p><h3 id="ような"><a href="#ような" class="headerlink" title="~ような"></a>~ような</h3><p>このような本//比较书面<br>这样的书</p><p>こんな本//口语化<br>这样的书</p><h3 id="こ"><a href="#こ" class="headerlink" title="~こ"></a>~こ</h3><p>ここは学校だ<br>这里是学校</p><p><em>没有あこ的用法，应是あそこ</em></p><p>教室はどこですか。//は提示后面的<br>どこが教室ですか。//が提示前面的<br>教室在哪儿？</p><h3 id="ちら-用法等于-こ-更加礼貌"><a href="#ちら-用法等于-こ-更加礼貌" class="headerlink" title="~ちら 用法等于~こ,更加礼貌"></a>~ちら 用法等于~こ,更加礼貌</h3><p>こちらは私の先生です。<br>这位是我的老师。</p><p>こちらは毛利探偵事務所でございます。<br>这里是毛利侦探事务所。</p><p><em>こちら在口语中可简化为こち</em></p><h3 id="指示代词总结"><a href="#指示代词总结" class="headerlink" title="指示代词总结"></a>指示代词总结</h3><table><thead><tr><th align="center"></th><th align="center">こ</th><th align="center">そ</th><th align="center">あ</th><th align="center">ど</th><th align="center"></th></tr></thead><tbody><tr><td align="center">~れ</td><td align="center">これ</td><td align="center">それ</td><td align="center">あれ</td><td align="center">どれ</td><td align="center">后加助词，指代事物</td></tr><tr><td align="center">~の</td><td align="center">この</td><td align="center">その</td><td align="center">あの</td><td align="center">どの</td><td align="center">后加名词，指代事物</td></tr><tr><td align="center">~ような</td><td align="center">このような</td><td align="center">そのような</td><td align="center">あのような</td><td align="center">どのような</td><td align="center">指代样态，“这样的，怎样的”</td></tr><tr><td align="center">~んな</td><td align="center">こんな</td><td align="center">そんな</td><td align="center">あんな</td><td align="center">どんな</td><td align="center">为上一行的缩略表达</td></tr><tr><td align="center">~こ</td><td align="center">ここ</td><td align="center">そこ</td><td align="center">あそこ</td><td align="center">どこ</td><td align="center">指代地点</td></tr><tr><td align="center">~ちら</td><td align="center">こちら</td><td align="center">そちら</td><td align="center">あちら</td><td align="center">どちら</td><td align="center">指代地点，郑重，还可间接指代人</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2023/01/22/c-biao-zhun-mo-ban-ku-stl/"/>
      <url>/2023/01/22/c-biao-zhun-mo-ban-ku-stl/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是C-标准模板库（STL）？"><a href="#什么是C-标准模板库（STL）？" class="headerlink" title="什么是C++标准模板库（STL）？"></a>什么是C++标准模板库（STL）？</h2><p>标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。</p><p>C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。</p><p>C++ 语言的核心优势之一就是便于软件的复用。</p><p>C++ 语言有两个方面体现了复用：</p><p>1.面向对象的继承和多态机制<br>2.通过模板的概念实现了对泛型程序设计的支持</p><p>STL有什么优势？<br>STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。<br><em>P.S. 如果对STL源码有兴趣，可读C++大师侯捷的《STL源码剖析》</em></p><h2 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h2><h2 id="容器（Containers）"><a href="#容器（Containers）" class="headerlink" title="容器（Containers）"></a>容器（Containers）</h2><p>[vector]<a href="https://myq0721.github.io/2023/02/05/vector-yong-fa-zong-jie/">https://myq0721.github.io/2023/02/05/vector-yong-fa-zong-jie/</a></p><h3 id="分配器（Allocators）"><a href="#分配器（Allocators）" class="headerlink" title="分配器（Allocators）"></a>分配器（Allocators）</h3><h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><h3 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h3><h3 id="适配器（Adapters）"><a href="#适配器（Adapters）" class="headerlink" title="适配器（Adapters）"></a>适配器（Adapters）</h3><h3 id="仿函数（Functors）"><a href="#仿函数（Functors）" class="headerlink" title="仿函数（Functors）"></a>仿函数（Functors）</h3><p><em>详细</em><br><em><a href="https://zhuanlan.zhihu.com/p/344558356">https://zhuanlan.zhihu.com/p/344558356</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——1.名词谓语句</title>
      <link href="/2023/01/22/ri-yu-yu-fa-1.ming-ci-wei-yu-ju/"/>
      <url>/2023/01/22/ri-yu-yu-fa-1.ming-ci-wei-yu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。"><a href="#日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。" class="headerlink" title="日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。"></a>日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。</h1><h3 id="だ-表达判断"><a href="#だ-表达判断" class="headerlink" title="~だ 表达判断"></a>~だ 表达判断</h3><p>学生だ<br>是学生</p><p>学生ではない<br>不是学生</p><p>学生（か）？<br>是学生吗？</p><h3 id="です-表达判断（对听话人礼貌）"><a href="#です-表达判断（对听话人礼貌）" class="headerlink" title="~です　表达判断（对听话人礼貌）"></a>~です　表达判断（对听话人礼貌）</h3><p>学生です<br>是学生</p><p>学生でわありませえ<br>不是学生</p><p>学生ですか？<br>是学生吗？</p><p>先生ですか、学生ですか。//前读降调后读声调<br>是老师还是学生</p><h3 id="である-表判断（用在演讲或论文中，非常正式）"><a href="#である-表判断（用在演讲或论文中，非常正式）" class="headerlink" title="~である　表判断（用在演讲或论文中，非常正式）"></a>~である　表判断（用在演讲或论文中，非常正式）</h3><p>学生である</p><p>学生であります</p><h3 id="でございます（敬语，店家对客人等）"><a href="#でございます（敬语，店家对客人等）" class="headerlink" title="~でございます（敬语，店家对客人等）"></a>~でございます（敬语，店家对客人等）</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center"></th><th align="center">一般</th><th align="center">礼貌</th><th align="center">正式</th><th align="center">正式+礼貌</th><th align="center">郑重</th></tr></thead><tbody><tr><td align="center">肯定</td><td align="center">だ</td><td align="center">です</td><td align="center">である</td><td align="center">であります</td><td align="center">でございます</td></tr><tr><td align="center">否定</td><td align="center">ではない</td><td align="center">ではありません</td><td align="center">/</td><td align="center">/</td><td align="center">/</td></tr></tbody></table><hr><h3 id="は-x2F-が"><a href="#は-x2F-が" class="headerlink" title="~は/が"></a>~は/が</h3><ul><li><p>你是谁？<br>我是学生。——&gt; 私は学生だ。//强调は后的部分</p></li><li><p>谁是学生？<br>我是学生。——&gt; 私が学生だ。//强调が前的部分</p></li></ul><h3 id="も"><a href="#も" class="headerlink" title="~も"></a>~も</h3><p>我是学生，他也是学生。<br>私は学生です。彼も学生です。//</p>]]></content>
      
      
      <categories>
          
          <category> 日语学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日语语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/2023/01/20/markdown-ji-chu-yu-fa/"/>
      <url>/2023/01/20/markdown-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown?"></a>什么是Markdown?</h2><p>&nbsp;  Markdown就是一种文档的格式，文件名的末尾是.md，正如我们常用的word文档格式是.doc、.docx，需要对应的软件来打开这一种格式。</p><h2 id="为什么要用Markdown？"><a href="#为什么要用Markdown？" class="headerlink" title="为什么要用Markdown？"></a>为什么要用Markdown？</h2><p>作为一种新的文档格式，我们放着这么好的word文档不用却用Markdown是有一些原因的：</p><p>有人发现当他们用Word或者别的文本编辑器写好一篇文章，兴高采烈地发布到博客、论坛、网站上时，发现格式完全乱了，于是需要花费大量的时间来重新排版，处理图片、缩进、字体、加粗、标题等。三番五次之后，开始发现文章写作可能只花了半小时，重新排版就花了十多分钟。更让人不悦的是，当我们要把同一篇文章发布到另一个网页上时，这样的排版还要重新做一次。</p><p>并且习惯了非可视化界面后，使用鼠标操作意味着终断打字，是一个显著降低输入速度的行为。一般来说文章的编写必然需要设置一定的格式：标题、加粗、行距、缩进、字体……这些一般都需要用鼠标在可视化界面上选择。</p><h2 id="1-删除线："><a href="#1-删除线：" class="headerlink" title="1.删除线："></a>1.删除线：</h2><p>用法：<code>~~要划删除线的文字~~</code></p><p>例如：<code>~~HelloWorld~~</code></p><p>显示：<del>HelloWorld</del></p><h2 id="2-下划线："><a href="#2-下划线：" class="headerlink" title="2.下划线："></a>2.下划线：</h2><p>用法：<code>&lt;u&gt;要添加下划线的文字&lt;/u&gt;</code></p><p>例如：<code>&lt;u&gt;HelloWorld&lt;/u&gt;</code></p><p>显示：<u>HelloWorld</u></p><h2 id="3-分割线："><a href="#3-分割线：" class="headerlink" title="3.分割线："></a>3.分割线：</h2><p>用法：<code>---</code>  <em>//需要单独的一行！</em></p><p>例如：<code>---</code></p><p>显示：</p><hr><h2 id="4-标题："><a href="#4-标题：" class="headerlink" title="4.标题："></a>4.标题：</h2><p>用法：<code># 标题内容</code> // 需要单独一行</p><p><em>如果需要标题下面的小标题可以多加一个“#”符号</em></p><p>例如：<code># 显示效果</code></p><p>显示：</p><h1 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h1><h2 id="5-加粗："><a href="#5-加粗：" class="headerlink" title="5.加粗："></a>5.加粗：</h2><p>用法：<code>**加粗内容**</code></p><p>例如：<code>**HelloWorld**</code></p><p>显示：<strong>HelloWorld</strong></p><h2 id="6-斜体："><a href="#6-斜体：" class="headerlink" title="6.斜体："></a>6.斜体：</h2><p>用法：<code>*斜体内容*</code></p><p>例如：<code>*HelloWorld*</code></p><p>显示：<em>HelloWorld</em></p><h2 id="7-既斜体又加粗："><a href="#7-既斜体又加粗：" class="headerlink" title="7.既斜体又加粗："></a>7.既斜体又加粗：</h2><p>用法：<code>***斜体又加粗内容***</code></p><p>例如：<code>***HelloWorld***</code></p><p>显示：<em><strong>HelloWorld</strong></em></p><h2 id="8-无序列表："><a href="#8-无序列表：" class="headerlink" title="8.无序列表："></a>8.无序列表：</h2><p>用法：<code>- 内容</code> // 需要单独一行</p><p>例如：</p><p><code>- HelloWorld</code></p><p><code>- HelloMarkdown</code></p><p>显示：</p><ul><li><p>HelloWorld</p></li><li><p>HelloMarkdown</p></li></ul><h2 id="9-有序列表："><a href="#9-有序列表：" class="headerlink" title="9.有序列表："></a>9.有序列表：</h2><p>用法：</p><p><code>1. 内容</code></p><p><code>2. 内容</code></p><p><code>3. 内容</code></p><p>// 可以不按数字顺序，但必须从1开始</p><p>例如：</p><p><code>1. HelloWorld</code></p><p><code>2. HelloMarkdown</code></p><p><code>3. Markdown yes</code></p><p>显示：</p><ol><li><p>HelloWorld</p></li><li><p>HelloMarkdown</p></li><li><p>Markdown yes</p></li></ol><h2 id="10-引用内容："><a href="#10-引用内容：" class="headerlink" title="10.引用内容："></a>10.引用内容：</h2><h2 id="单行："><a href="#单行：" class="headerlink" title="单行："></a>单行：</h2><p>用法：<code>&gt; 引用内容</code> //  需要单独一行</p><p>例如：<code>&gt; HelloWorld by Markdown</code></p><p>显示：</p><blockquote><p>HelloWorld by Markdown</p></blockquote><h2 id="空行："><a href="#空行：" class="headerlink" title="空行："></a>空行：</h2><p>用法：</p><p><code>&gt; 第一行</code></p><p><code>&gt;</code></p><p><code>&gt; 第二行</code></p><p>例如：</p><p><code>&gt; HelloWorld by Markdown 1</code></p><p><code>&gt;</code></p><p><code>&gt; HelloWorld by Markdown 2</code></p><p>显示：</p><blockquote><p>HelloWorld by Markdown 1</p><p>HelloWorld by Markdown 2</p></blockquote><h2 id="嵌套："><a href="#嵌套：" class="headerlink" title="嵌套："></a>嵌套：</h2><p>用法：</p><p><code>&gt; 第一行</code></p><p><code>&gt; 第二行</code></p><p><code>&gt; &gt; 第二行引用的（需要嵌套的）</code></p><p>例如：</p><p><code>&gt; HelloWorld by Markdown 1</code></p><p><code>&gt; HelloWorld by Markdown 2</code></p><p><code>&gt; &gt; HelloWorld by Markdown 3</code></p><p>显示：</p><blockquote><p>HelloWorld by Markdown 1</p><p>HelloWorld by Markdown 2</p><blockquote><p>HelloWorld by Markdown 3</p></blockquote></blockquote><h2 id="带有其他语法的引用："><a href="#带有其他语法的引用：" class="headerlink" title="带有其他语法的引用："></a>带有其他语法的引用：</h2><p><code>&gt; ### HelloWorld</code></p><p><code>&gt;</code></p><p><code>&gt; - HelloWorld</code></p><p><code>&gt; - HelloMarkdown</code></p><p><code>&gt; - Markdown yes</code></p><p><code>&gt;</code></p><p><code>&gt; *Hello* **World**</code></p><p>显示：</p><blockquote><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><ul><li>HelloMarkdown</li><li>Markdown  yes</li></ul><p><em>Hello</em> <strong>World</strong></p></blockquote><h2 id="11-代码块："><a href="#11-代码块：" class="headerlink" title="11.代码块："></a>11.代码块：</h2><p>用法：三个```符号（要封口） （可以缩减成一个）</p><p>例如：```HelloWorld （要封口）</p><p>显示：<code>HelloWorld</code></p><h2 id="12-转义字符："><a href="#12-转义字符：" class="headerlink" title="12.转义字符："></a>12.转义字符：</h2><p>可以把本来要用来Markdown语法的字符转成正常字符</p><p>用法：<code>\</code></p><p>例如：<code>\*HelloWorld\*</code></p><p>显示：*HelloWorld*</p><h2 id="13-使用HTML标签："><a href="#13-使用HTML标签：" class="headerlink" title="13.使用HTML标签："></a>13.使用HTML标签：</h2><p>用法：直接写HTML标签</p><p>例如：<code>&lt;u&gt;HelloWorld&lt;/u&gt;</code></p><p>显示：<u>HelloWorld</u></p><p><em>（之前的下划线就是用的HTML标签，而不是Markdown语法）</em></p><h2 id="14-表格："><a href="#14-表格：" class="headerlink" title="14.表格："></a>14.表格：</h2><h2 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h2><p>用法：</p><pre class="line-numbers language-none"><code class="language-none">| 标题1   | 标题2 || -------|------ || 内容1   | 内容3 || 内容2   | 内容4 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（“|”是分割，”—“是竖着的分割线加粗）</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description || ----------- | ----------- || Header      | Title       || Paragraph   | Text        |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显示：</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><h2 id="自动对齐"><a href="#自动对齐" class="headerlink" title="自动对齐"></a>自动对齐</h2><p>用法：</p><pre class="line-numbers language-none"><code class="language-none">| 标题1      | 标题2 | 标题3     || :---:        |    :----:   |          :---: || 内容1      | 内容3     | 内容5   || 内容2   | 内容4        |内容6      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">标题1</th><th align="center">标题2</th><th align="center">标题3</th></tr></thead><tbody><tr><td align="center">内容1</td><td align="center">内容3</td><td align="center">内容5</td></tr><tr><td align="center">内容2</td><td align="center">内容4</td><td align="center">内容6</td></tr></tbody></table><h2 id="15-任务完成表"><a href="#15-任务完成表" class="headerlink" title="15.任务完成表"></a>15.任务完成表</h2><p>用法：</p><p><code>- [x] 打钩的内容</code></p><p><code>- [] 不打钩的内容</code></p><p>例如：</p><p><code>- [x] Markdown yes</code></p><p><code>- [] Word Yes</code></p><p>显示</p><ul><li><p><input checked="" disabled="" type="checkbox"> Markdown yes</p></li><li><p><input disabled="" type="checkbox"> Word Yes</p></li></ul><p>更多请看<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics</a><br>以及<a href="https://markdown.com.cn/basic-syntax/images.html">https://markdown.com.cn/basic-syntax/images.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用现代OpenGL绘制三角形</title>
      <link href="/2023/01/08/shi-yong-xian-dai-opengl-hui-zhi-san-jiao-xing/"/>
      <url>/2023/01/08/shi-yong-xian-dai-opengl-hui-zhi-san-jiao-xing/</url>
      
        <content type="html"><![CDATA[<p>没有shader的版本</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;GL/glew.h&gt;//glew必须在glfw前#include &lt;GLFW/glfw3.h&gt;#include&lt;iostream&gt;int main(void){    GLFWwindow* window;    /* Initialize the library */    if (!glfwInit())        return -1;    glewInit();    /* Create a windowed mode window and its OpenGL context */    window = glfwCreateWindow(640, 480, "OpenGl", NULL, NULL);    if (!window)    {        glfwTerminate();        return -1;    }    /* Make the window's context current */    glfwMakeContextCurrent(window);    //---此后才有有效的渲染环境---    if (glewInit() != GLEW_OK) {//检测        std::cout &lt;&lt; "Error" &lt;&lt; std::endl;    }    std::cout &lt;&lt; glGetString(GL_VERSION) &lt;&lt; std::endl;    float position[6] = {        -0.5f, -0.5f,         0.0f,  0.5f,         0.5f, -0.5f    };        unsigned int buffer;    glGenBuffers(1, &amp;buffer);    glBindBuffer(GL_ARRAY_BUFFER, buffer);    glBufferData(GL_ARRAY_BUFFER,sizeof(position),position,GL_STATIC_DRAW);    glEnableVertexAttribArray(0);    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0);    glBindBuffer(GL_ARRAY_BUFFER, 0);    /* Loop until the user closes the window */    while (!glfwWindowShouldClose(window))    {        /* Render here */        glClear(GL_COLOR_BUFFER_BIT);        glDrawArrays(GL_TRIANGLES,0,3);        /* Swap front and back buffers */        glfwSwapBuffers(window);        /* Poll for and process events */        glfwPollEvents();    }    glfwTerminate();    return 0;}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 图形学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> OpenGL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matery主题的Front-matter</title>
      <link href="/2023/01/05/matery-zhu-ti-de-front-matter/"/>
      <url>/2023/01/05/matery-zhu-ti-de-front-matter/</url>
      
        <content type="html"><![CDATA[<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>摘自matery的README_CN，方便自己使用</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ayanami的第一篇blog</title>
      <link href="/2022/03/20/ling-bo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2022/03/20/ling-bo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="使用笔记"><a href="#使用笔记" class="headerlink" title="使用笔记"></a>使用笔记</h2><p>node -v#查看node版本<br>npm -v#查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>#安装淘宝的cnpm 管理器<br>cnpm -v#查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v#查看hexo版本<br>mkdir blog#创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客<br>hexo s#启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>#本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p><p>#配置_config.yml<br>    # Deployment<br>    ## Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a><br>    deploy:<br>          type: git<br>         repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>          branch: master<br>hexo d#部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</p><p> git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c#清理一下<br>hexo g#生成<br>hexo d#部署到远程Github仓库</p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/20/hello-world/"/>
      <url>/2022/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 其他 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

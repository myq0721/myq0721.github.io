<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>随笔与牢骚与乱七八糟的合集/发癫日记</title>
      <link href="/2023/02/05/sui-bi-yu-lao-sao-he-luan-qi-ba-zao-de-he-ji/"/>
      <url>/2023/02/05/sui-bi-yu-lao-sao-he-luan-qi-ba-zao-de-he-ji/</url>
      
        <content type="html"><![CDATA[<p><code>warning!警告!</code></p><p><code>以下内容将毫无营养</code></p><hr><hr><hr><h4 id="02-x2F-05"><a href="#02-x2F-05" class="headerlink" title="02/05"></a>02/05</h4>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何成为一名图形算法工程师</title>
      <link href="/2023/02/05/ru-he-cheng-wei-yi-ming-tu-xing-suan-fa-gong-cheng-shi/"/>
      <url>/2023/02/05/ru-he-cheng-wei-yi-ming-tu-xing-suan-fa-gong-cheng-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者是从游戏引擎第一次接触计算机图形学，所以更多的是偏渲染向的，特别是实时渲染。这里存一些学习路径或者学习资料，教程网站之类的东西。</p><p>图形学作为程序员三大浪漫，（另外两个是编译原理和操作系统，虽然有有人说加上网络hhh），但我觉得图形学和网络是最浪漫的cs方向<span class="github-emoji"><span>😋</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60b.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span><br>好像能看到但目标又好像那么遥远，有一种爱而不得的美。</p><p>上面是开玩笑的，但是很多图形学的算法确实是很美妙~<span class="github-emoji"><span>😇</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f607.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h2 id="什么是计算机图形学"><a href="#什么是计算机图形学" class="headerlink" title="什么是计算机图形学"></a><a href="http://staff.ustc.edu.cn/~lgliu/Resources/CG/What_is_CG.htm">什么是计算机图形学</a></h2><p><a href="http://staff.ustc.edu.cn/~lgliu">刘立刚</a></p><p>简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。</p><p>实际上，计算机图形学、数字图象处理和计算机视觉在很多地方的区别并不非常清晰，很多都是相通的。</p><p>笔者觉得学习一门知识，一个研究方向，就好比在沙地上挖坑。随着本方向的领域研究越发深入，其相关的知识与技能需求也会逐步的跟进并且范围会越来越大。在知识的领域，真的只集中一点往往并不能登封造极。</p><hr><h2 id="如何学习计算机图形学"><a href="#如何学习计算机图形学" class="headerlink" title="如何学习计算机图形学"></a><a href="http://staff.ustc.edu.cn/~lgliu/Resources/CG/How_to_Learn_CG&amp;Coding.htm">如何学习计算机图形学</a></h2><h3 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h3><p>数学知识，如线性代数、三维几何学、微积分等。<br>数学在图形学中的应用，透视投影、光线追踪、景深模拟等</p><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>编程语言，如C++、Python等。<br>编程语言的高级特性，模板、多线程、编译器优化等。</p><h3 id="图形学基础"><a href="#图形学基础" class="headerlink" title="图形学基础"></a>图形学基础</h3><p>图形学基本概念，如渲染算法、光照模型、几何学等。<br>图形学基本流程，例如对三维模型的投影、照明、深度测试等。</p><h3 id="图形学工具"><a href="#图形学工具" class="headerlink" title="图形学工具"></a>图形学工具</h3><p>熟悉常用的图形学工具，如OpenGL、DirectX等。<br>了解图形学工具的特点，支持的渲染模型、硬件加速等。</p><h3 id="图形学算法"><a href="#图形学算法" class="headerlink" title="图形学算法"></a>图形学算法</h3><p>了解常用算法，光线追踪、景深模拟、半透明合并等。<br>学会使用图形学算法解决问题，例如模拟自然环境、动态角色行为等。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>不断学习计算机图形学领域的最新技术，保持对技术的敏感和兴趣。</p><p>通过阅读技术文章、或技术会议等方式，了解最新发展方向和应用。</p><p>通过实际项目的开发积累实践经验，制作游戏等。<br>利用实践经验检验自己的技能，不断提高自己的专业水平。</p><p>与同行交流互相学习，增加对图形学的理解。<br>在团队合作的过程中，学习如何协作解决复杂的问题。</p><h2 id="资料整理"><a href="#资料整理" class="headerlink" title="资料整理"></a>资料整理</h2><p>1.大学图形学课程的课本是Donald Hearn的Computer Graphics第四版<br><img src="https://tudingtu.cn/i/2023/02/05/11au0iv.jpg" alt="Computer Graphics"></p><p>2.<a href="http://www.kevinbeason.com/smallpt/">实现基于Path Tracing的光线追踪渲染器</a></p><p>3.软渲染</p><p><a href="http://www.3dcpptutorials.sk/index.php?id=15">3D C/C++ tutorials - Software rendering</a></p><p><a href="https://trenki2.github.io/blog/2017/06/06/developing-a-software-renderer-part1">Developing a Software Renderer Part 1</a></p><p>4.opengl(虽然很老了，但确实经典)</p><p><a href="https://learnopengl-cn.github.io/#">opengl文档</a></p><p><a href="https://www.youtube.com/@TheCherno/playlists">cherno大佬</a>&lt;–强烈推荐</p>]]></content>
      
      
      
        <tags>
            
            <tag> 图形学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作与考研的二三事</title>
      <link href="/2023/02/05/gong-zuo-yu-kao-yan/"/>
      <url>/2023/02/05/gong-zuo-yu-kao-yan/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tuple用法总结</title>
      <link href="/2023/02/05/tuple-yong-fa-zong-jie/"/>
      <url>/2023/02/05/tuple-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="tuple简介"><a href="#tuple简介" class="headerlink" title="tuple简介"></a>tuple简介</h2><p>tuple（元组）在c++11中开始引用的。tuple看似简单，其实它是简约而不简单，可以说它是c++11中一个既简单又复杂的东西。</p><p>tuple是一个固定大小的不同类型值的集合，是泛化的std::pair。</p><p>我们也可以把他当做一个通用的结构体来用，不需要创建结构体又获取结构体的特征，在某些情况下可以取代结构体使程序更简洁，直观。</p><p>std::tuple理论上可以有无数个任意类型的成员变量，而std::pair只能是2个成员，因此在需要保存3个及以上的数据时就需要使用tuple元组了。</p><h2 id="tuple的创建和初始化"><a href="#tuple的创建和初始化" class="headerlink" title="tuple的创建和初始化"></a>tuple的创建和初始化</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> std::tuple&lt;T1, T2, TN&gt; t1;//创建一个空的tuple对象,它对应的元素分别是T1和T2...Tn类型，采用值初始化。std::tuple&lt;T1, T2, TN&gt; t2(v1, v2, ... TN);//创建一个tuple对象，它的两个元素分别是T1和T2 ...Tn类型; 要获取元素的值需要通过tuple的成员get&lt;Ith&gt;(obj)进行获取(Ith是指获取在tuple中的第几个元素)。std::tuple&lt;T1&amp;&gt; t3(ref&amp;); // tuple的元素类型可以是一个引用std::make_tuple(v1, v2); // 像pair一样也可以通过make_tuple进行创建一个tuple对象// tuple的元素类型为引用：std::string name;std::tuple&lt;string &amp;, int&gt; tpRef(name, 30);// 对tpRef第一个元素赋值，同时name也被赋值 - 引用std::get&lt;0&gt;(tpRef) = "Sven"; // name输出也是Svenstd::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt; '\n';<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="tuple的操作"><a href="#tuple的操作" class="headerlink" title="tuple的操作"></a>tuple的操作</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//1.等价结构体struct person {    char *m_name;    char *m_addr;    int  *m_ages;};//可以用tuple来表示这样的一个结构类型，作用是一样的。std::tuple&lt;const char *, const char *, int&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//2.获取tuple个数#include &lt;iostream&gt;#include &lt;tuple&gt;int main (){  std::tuple&lt;int, char, double&gt; mytuple (10, 'a', 3.14);  std::cout &lt;&lt; "mytuple has ";  std::cout &lt;&lt; std::tuple_size&lt;decltype(mytuple)&gt;::value;  std::cout &lt;&lt; " elements." &lt;&lt; '\n';  return 0;}//输出结果：mytuple has 3 elements<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//3.获取元素的值#include &lt;iostream&gt;#include &lt;tuple&gt;int main (){  std::tuple&lt;int, char, double&gt; mytuple (10, 'a', 3.14);  std::cout &lt;&lt; "mytuple has ";  std::cout &lt;&lt; std::tuple_size&lt;decltype(mytuple)&gt;::value;  std::cout &lt;&lt; " elements." &lt;&lt; '\n';  //获取元素  std::cout &lt;&lt; "the elements is: ";  std::cout &lt;&lt; std::get&lt;0&gt;(mytuple) &lt;&lt; " ";  std::cout &lt;&lt; std::get&lt;1&gt;(mytuple) &lt;&lt; " ";  std::cout &lt;&lt; std::get&lt;2&gt;(mytuple) &lt;&lt; " ";  std::cout &lt;&lt; '\n';  return 0;}/*输出结果：mytuple has 3 elements.the elements is: 10 a 3.14 */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p><strong>注意：tuple不支持迭代，只能通过元素索引(或tie解包)进行获取元素的值。但是给定的索引必须是在编译器就已经给定，不能在运行期进行动态传递，否则将发生编译错误：如：</strong></p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">&gt;for(int i=0; i&lt;3; i++)   std::cout &lt;&lt; std::get&lt;i&gt;(mytuple) &lt;&lt; " "; //将引发编译错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></blockquote><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//4.获取元素的类型//要想得到元素类型可以通过tuple_element方法获取，如有以下元组对象：std::tuple&lt;std::string, int&gt; tp("Sven", 20);// 得到第二个元素类型std::tuple_element&lt;1, decltype(tp)&gt;::type ages;  // ages就为int类型 ages = std::get&lt;1&gt;(tp); std::cout &lt;&lt; "ages: " &lt;&lt; ages &lt;&lt; '\n'; //输出结果:ages: 20<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++"> //5.利用tie进行解包元素的值 //如同pair一样也是可以通过tie进行解包tuple的各个元素的值。如下tuple对象有4个元素，通过tie解将会把这4个元素的值分别赋值给tie提供的4个变量中。#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;utility&gt; int main(int argc, char **argv) {    std::tuple&lt;std::string, int, std::string, int&gt; tp;    tp = std::make_tuple("Sven", 25, "Shanghai", 21);     // 定义接收变量    std::string name;    std::string addr;    int ages;    int areaCode;     std::tie(name, ages, addr, areaCode) = tp;    std::cout &lt;&lt; "Output: " &lt;&lt; '\n';    std::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt;", ";    std::cout &lt;&lt; "addr: " &lt;&lt; addr &lt;&lt; ", ";    std::cout &lt;&lt; "ages: " &lt;&lt; ages &lt;&lt; ", ";    std::cout &lt;&lt; "areaCode: " &lt;&lt; areaCode &lt;&lt; '\n';     return 0;} /*输出结果：Output: name: Sven, addr: Shanghai, ages: 25, areaCode: 21*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但有时候tuple包含的多个元素时只需要其中的一个或两个元素，如此可以通过std::ignore进行变量占位，这样将会忽略提取对应的元素。可以修改上述例程：</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;utility&gt; int main(int argc, char **argv) {    std::tuple&lt;std::string, int, std::string, int&gt; tp;    tp = std::make_tuple("Sven", 25, "Shanghai", 21);     // 定义接收变量    std::string name;    std::string addr;    int ages;    int areaCode = 110;     std::tie(name, ages, std::ignore, std::ignore) = tp;    std::cout &lt;&lt; "Output: " &lt;&lt; '\n';    std::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt;", ";    std::cout &lt;&lt; "addr: " &lt;&lt; addr &lt;&lt; ", ";    std::cout &lt;&lt; "ages: " &lt;&lt; ages &lt;&lt; ", ";    std::cout &lt;&lt; "areaCode: " &lt;&lt; areaCode &lt;&lt; '\n';     return 0;} /*输出结果：Output: name: Sven, addr: , ages: 25, areaCode: 110*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">//6. tuple元素的引用//前面已经列举了将引用作为tuple的元素类型。下面通过引用搭配make_tuple()可以提取tuple的元素值，将某些变量值设给它们，并通过改变这些变量来改变tuple元素的值：#include &lt;iostream&gt;#include &lt;tuple&gt;#include &lt;functional&gt; int main(int argc, char **agrv) {     std::tuple&lt;std::string, int, float&gt; tp1("Sven Cheng", 77, 66.1);     std::string name;    int weight;    float f;     auto tp2 = std::make_tuple(std::ref(name), std::ref(weight), std::ref(f)) = tp1;     std::cout &lt;&lt; "Before change: " &lt;&lt; '\n';    std::cout &lt;&lt; "name: " &lt;&lt; name &lt;&lt; ", ";    std::cout &lt;&lt; "weight: " &lt;&lt; weight &lt;&lt; ", ";    std::cout &lt;&lt; "f: " &lt;&lt; f &lt;&lt; '\n';     name = "Sven";    weight = 80;    f = 3.14; std::cout &lt;&lt; "After change: " &lt;&lt; '\n';std::cout &lt;&lt; "element 1st: " &lt;&lt; std::get&lt;0&gt;(tp2) &lt;&lt; ", ";std::cout &lt;&lt; "element 2nd: " &lt;&lt; std::get&lt;1&gt;(tp2) &lt;&lt; ", ";std::cout &lt;&lt; "element 3rd: " &lt;&lt; std::get&lt;2&gt;(tp2) &lt;&lt; '\n';     return 0;} /*输出结果：Before change: name: Sven Cheng, weight: 77, f: 66.1After change: element 1st: Sven, element 2nd: 80, element 3rd: 3.14*/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vector用法总结</title>
      <link href="/2023/02/01/vector-yong-fa-zong-jie/"/>
      <url>/2023/02/01/vector-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="vector相关的用法总结"><a href="#vector相关的用法总结" class="headerlink" title="vector相关的用法总结"></a>vector相关的用法总结</h2><p>因为最近经常用，于是总结在这个地方。</p><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>1.顺序序列<br>顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p><p>2.动态数组<br>支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。提供了在序列末尾相对快速地添加/删除元素的操作。</p><p>3.能够感知内存分配器的（Allocator-aware）<br>容器使用一个内存分配器对象来动态地处理它的存储需求。</p><hr><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><p>使用vector需要注意以下几点：</p><p>1.如果你要表示的向量长度较长（需要为向量内部保存很多数），容易导致内存泄漏，而且效率会很低；</p><p>2.Vector作为函数的参数或者返回值时，需要注意它的写法：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">double Distance(vector&lt;int&gt;&amp;a, vector&lt;int&gt;&amp;b); //其中的“&amp;”不能少<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>3.vector的元素不仅仅可以是int,double,string,还，可以是结构体，但是要注意：结构体要定义为全局的.</p><h2 id="常见使用"><a href="#常见使用" class="headerlink" title="常见使用"></a>常见使用</h2><p>使用：</p><pre class="line-numbers language-C++" data-language="C++"><code class="language-C++">#include&lt;vector&gt;vector&lt;int&gt; vec;///建立一个vector，int为数组元素的数据类型，vec为动态数组名vector&lt;vector&lt;long int&gt; &gt; vec2; //定义一个二维数组vec2vec.push_back(1);vec.push_back(2);//把1和2压入vector，这样vec[0]就是1,vec[1]就是2cout&lt;&lt;vec[0]&lt;&lt;endl;//使用下标访问元素//使用迭代器访问元素.vector&lt;int&gt;::iterator it;for(it=vec.begin();it!=vec.end();it++)    cout&lt;&lt;*it&lt;&lt;endl;vec.insert(vec.begin()+i,a);//插入,在第i+1个元素前面插入avec.erase(vec.begin()+2);//删除元素,删除第3个元素vec.erase(vec.begin()+i,vec.end()+j);//删除区间[i,j-1];区间从0开始vec.size();//向量大小vec.clear();//清空<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一些算法</p><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">#include&lt;algorithm&gt;reverse(vec.begin(),vec.end());//将元素翻转，即逆序排列sort(vec.begin(),vec.end());//默认升序排列//降序排列需重写bool Comp(const int &amp;a,const int &amp;b){    return a&gt;b;}sort(vec.begin(),vec.end(),Comp)//降序排序//交换两个同类型向量的数据vector&lt;int&gt;vec2;swap(vec,vec2);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>先这样，之后用到了再加叭qaq <span class="github-emoji"><span>😊</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/1f60a.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span>~</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——4.形容词，形容动词</title>
      <link href="/2023/01/28/ri-yu-yu-fa-4-xing-rong-ci-xing-rong-dong-ci/"/>
      <url>/2023/01/28/ri-yu-yu-fa-4-xing-rong-ci-xing-rong-dong-ci/</url>
      
        <content type="html"><![CDATA[<h3 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h3><p>空は青い。<br>空は青いです。//更礼貌<br>天空是蓝色的。</p><p><em>形容词可以直接做谓语后不需加だ，做终止形</em></p><p>青い空。<br>蓝色的天空。</p><p><em>形容词做定语，直接加名词，不加の，做连体形</em><br><em>名词代词等即体言</em></p><h3 id="形容动词"><a href="#形容动词" class="headerlink" title="形容动词"></a>形容动词</h3><p><em>形容动词的变化方式和动词相同</em></p><p>教室は静かだ。<br>教室は静かです。<br>教室安静。</p><p>静かな教室。<br>安静的教室</p><p><em>だ变な由终止形变连体形</em></p><h3 id="く-x2F-で"><a href="#く-x2F-で" class="headerlink" title="~く/で"></a>~く/で</h3><p><em>形容词，形容动词，与动词称为用言</em><br><em>同理，连接用眼的部分即为连用形</em></p><p>教室は大きく、静かだ。<br>教室很大也很安静。</p><p><em>形容词い变く，变连用形</em></p><p>教室は静かで、大きい。<br>教室很安静也很大。</p><p><em>形容动词以で结尾，变连用形，和名词相同</em></p><h3 id="ない"><a href="#ない" class="headerlink" title="~ない"></a>~ない</h3><p>この本は面白くない。<br>この本は面白くないです。//敬<br>この本は面白くありません。//敬<br>这本书没意思。</p><p><em>因为后要加ない这个补助形容词,面白い变面白く，即变为连用形</em></p><p>あの俳優さんは有名ではない。<br>あの俳優さんは有名ではありません。<br>那个演员没有名气。</p><h3 id="かつた-x2F"><a href="#かつた-x2F" class="headerlink" title="~かつた/"></a>~かつた/</h3><p><em>连用形的过去式</em></p><p>昨日は寒かっだ。<br>昨日は寒かっだです。<br>昨天冷。</p><p>昨日は寒くなかっだ。<br>昨日は寒くなかっだです。<br>昨日は寒くありませんでした。//でした表过去<br>昨天不冷。</p><p>寒<del>い</del><br>　く＋な<del>い</del><br>　　　　かっだ</p><p><em>为了加ない、寒い变寒く</em><br><em>然后把ない变~かっだ、即过去式的连用形</em></p><h3 id="だった"><a href="#だった" class="headerlink" title="~だった"></a>~だった</h3><p>私はもともと学生だった//だ变だった表过去<br>私はもともと学生でした。//更礼貌<br>我原本是个学生。</p><p>昨日教室は静かだった。<br>昨日教室は静かでした。<br>昨天教室安静。</p><p>昨日教室は静かではなかっだ。<br>昨日教室は静かではありませんでした。<br>昨天教室不安静。</p><h3 id="连体词"><a href="#连体词" class="headerlink" title="连体词"></a>连体词</h3><p><em>只能连接体言的词语</em></p><p>大きな<br>大的</p><p>小さな<br>小的</p><p>色んな<br>各式各样的</p><p><em>上面三个只有连体词一种词性</em></p><p>同じ<br>一样的<br><em>而同じ还是个形容动词，同じだ/です等</em></p>]]></content>
      
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——3.人称代词</title>
      <link href="/2023/01/25/ri-yu-yu-fa-3-ren-cheng-dai-ci/"/>
      <url>/2023/01/25/ri-yu-yu-fa-3-ren-cheng-dai-ci/</url>
      
        <content type="html"><![CDATA[<h3 id="一人称"><a href="#一人称" class="headerlink" title="一人称"></a>一人称</h3><table><thead><tr><th align="center">私（わたし）</th><th align="center">日常女性使用，正式场合男女通用</th></tr></thead><tbody><tr><td align="center">私（わたくし）</td><td align="center">男女通用，正式场合</td></tr><tr><td align="center">僕</td><td align="center">男，非正式</td></tr><tr><td align="center">俺</td><td align="center">男，粗鲁</td></tr><tr><td align="center">俺様</td><td align="center">男，居高临下，十分粗鲁</td></tr><tr><td align="center">あたし</td><td align="center">女性，随意，日常</td></tr><tr><td align="center">うち</td><td align="center">女性</td></tr></tbody></table><h3 id="二人称"><a href="#二人称" class="headerlink" title="二人称"></a>二人称</h3><h4 id="不知道对方姓名时："><a href="#不知道对方姓名时：" class="headerlink" title="不知道对方姓名时："></a>不知道对方姓名时：</h4><table><thead><tr><th align="center">あなた</th><th align="center">最常用，对平辈与晚辈使用，</th></tr></thead><tbody><tr><td align="center">君</td><td align="center">男性对同辈与晚辈使用</td></tr><tr><td align="center">お前</td><td align="center">男性对同辈与晚辈使用</td></tr><tr><td align="center">あんた</td><td align="center">比あなた更随意</td></tr><tr><td align="center">僕</td><td align="center">对不认识的小孩</td></tr></tbody></table><h4 id="知道对方姓名后，更礼貌的用语："><a href="#知道对方姓名后，更礼貌的用语：" class="headerlink" title="知道对方姓名后，更礼貌的用语："></a>知道对方姓名后，更礼貌的用语：</h4><h5 id="様-x2F-ちん-x2F-君-x2F-ちやん-x2F-殿（どの）-x2F-氏（し）"><a href="#様-x2F-ちん-x2F-君-x2F-ちやん-x2F-殿（どの）-x2F-氏（し）" class="headerlink" title="~様/~ちん/君/ちやん/殿（どの）/氏（し）"></a>~様/~ちん/君/ちやん/殿（どの）/氏（し）</h5><table><thead><tr><th align="center">佐藤様</th><th align="center">广泛，较礼貌，店家对客人等</th></tr></thead><tbody><tr><td align="center">佐藤さん</td><td align="center">日常</td></tr><tr><td align="center">佐藤君</td><td align="center">对同辈和晚辈，日常男性使用</td></tr><tr><td align="center">佐藤ちやん</td><td align="center">比较亲密</td></tr><tr><td align="center">営業部長殿</td><td align="center">前加职务，正式公文</td></tr><tr><td align="center">佐藤氏</td><td align="center">前加姓</td></tr><tr><td align="center">佐藤</td><td align="center">直呼，很亲密，或上对下，或对外人说自己人时</td></tr></tbody></table><h3 id="三人称"><a href="#三人称" class="headerlink" title="三人称"></a>三人称</h3><h4 id="人物："><a href="#人物：" class="headerlink" title="人物："></a>人物：</h4><table><thead><tr><th align="center">彼（かれ）</th><th align="center">他</th></tr></thead><tbody><tr><td align="center">彼女（かのじお）</td><td align="center">她</td></tr><tr><td align="center">こ/そ/あいつ</td><td align="center">它，家伙</td></tr></tbody></table><h4 id="物体："><a href="#物体：" class="headerlink" title="物体："></a>物体：</h4><p>こ/そ/あ/どれ       </p><hr><h3 id="复数表现"><a href="#复数表现" class="headerlink" title="复数表现"></a>复数表现</h3><table><thead><tr><th align="center">私（わたし）たち</th><th align="center">最常用，相当于“们”</th></tr></thead><tbody><tr><td align="center">あなたがだ</td><td align="center">较礼貌</td></tr><tr><td align="center">彼ら</td><td align="center">较不礼貌 <em>只有彼没有彼だち的用法</em></td></tr><tr><td align="center">私（わたくし）ども</td><td align="center">最礼貌，自谦语</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——2.指示代词</title>
      <link href="/2023/01/25/ri-yu-yu-fa-2-zhi-shi-dai-ci/"/>
      <url>/2023/01/25/ri-yu-yu-fa-2-zhi-shi-dai-ci/</url>
      
        <content type="html"><![CDATA[<h3 id="こ-指离说话人近的事物-x2F-近"><a href="#こ-指离说话人近的事物-x2F-近" class="headerlink" title="こ　指离说话人近的事物/近"></a>こ　指离说话人近的事物/近</h3><h3 id="そ-指离听话人近的事物-x2F-稍远"><a href="#そ-指离听话人近的事物-x2F-稍远" class="headerlink" title="そ　指离听话人近的事物/稍远"></a>そ　指离听话人近的事物/稍远</h3><h3 id="あ-指离双方都远的事物-x2F-很远"><a href="#あ-指离双方都远的事物-x2F-很远" class="headerlink" title="あ　指离双方都远的事物/很远"></a>あ　指离双方都远的事物/很远</h3><h3 id="ど-不定"><a href="#ど-不定" class="headerlink" title="ど　不定"></a>ど　不定</h3><hr><h3 id="れ、-の、-の"><a href="#れ、-の、-の" class="headerlink" title="~れ、~の、~の~"></a>~れ、~の、~の~</h3><p>これは本だ<br>这是书</p><p>この本は私の（本）だ<br>这本书是我的</p><h3 id="ような"><a href="#ような" class="headerlink" title="~ような"></a>~ような</h3><p>このような本//比较书面<br>这样的书</p><p>こんな本//口语化<br>这样的书</p><h3 id="こ"><a href="#こ" class="headerlink" title="~こ"></a>~こ</h3><p>ここは学校だ<br>这里是学校</p><p><em>没有あこ的用法，应是あそこ</em></p><p>教室はどこですか。//は提示后面的<br>どこが教室ですか。//が提示前面的<br>教室在哪儿？</p><h3 id="ちら-用法等于-こ-更加礼貌"><a href="#ちら-用法等于-こ-更加礼貌" class="headerlink" title="~ちら 用法等于~こ,更加礼貌"></a>~ちら 用法等于~こ,更加礼貌</h3><p>こちらは私の先生です。<br>这位是我的老师。</p><p>こちらは毛利探偵事務所でございます。<br>这里是毛利侦探事务所。</p><p><em>こちら在口语中可简化为こち</em></p><h3 id="指示代词总结"><a href="#指示代词总结" class="headerlink" title="指示代词总结"></a>指示代词总结</h3><table><thead><tr><th align="center"></th><th align="center">こ</th><th align="center">そ</th><th align="center">あ</th><th align="center">ど</th><th align="center"></th></tr></thead><tbody><tr><td align="center">~れ</td><td align="center">これ</td><td align="center">それ</td><td align="center">あれ</td><td align="center">どれ</td><td align="center">后加助词，指代事物</td></tr><tr><td align="center">~の</td><td align="center">この</td><td align="center">その</td><td align="center">あの</td><td align="center">どの</td><td align="center">后加名词，指代事物</td></tr><tr><td align="center">~ような</td><td align="center">このような</td><td align="center">そのような</td><td align="center">あのような</td><td align="center">どのような</td><td align="center">指代样态，“这样的，怎样的”</td></tr><tr><td align="center">~んな</td><td align="center">こんな</td><td align="center">そんな</td><td align="center">あんな</td><td align="center">どんな</td><td align="center">为上一行的缩略表达</td></tr><tr><td align="center">~こ</td><td align="center">ここ</td><td align="center">そこ</td><td align="center">あそこ</td><td align="center">どこ</td><td align="center">指代地点</td></tr><tr><td align="center">~ちら</td><td align="center">こちら</td><td align="center">そちら</td><td align="center">あちら</td><td align="center">どちら</td><td align="center">指代地点，郑重，还可间接指代人</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代游戏引擎——1.整体认知</title>
      <link href="/2023/01/23/xian-dai-you-xi-yin-qing-1-zheng-ti-ren-zhi/"/>
      <url>/2023/01/23/xian-dai-you-xi-yin-qing-1-zheng-ti-ren-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>游戏引擎是一个及其庞大而又复杂的系统工程，其中的任何一层或一个模块都有很深的学问。正因如此，我们需要从一个宏观的角度对游戏引擎有一个整体的认知。理通之后，在对其中的某个方面进行深度的研究时才能事半功倍。</p><p>从这样的角度来说笔者较为推荐《游戏引擎架构》,games104，或youtube上的TheCherno大神。至于具体各个功能，例如渲染的《Real-Time Rendering》等资料，在讨论相关板块时再分别提及。<br>而这系列博客主要以分享前三者的学习情况为主。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 游戏引擎开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++标准模板库(STL)</title>
      <link href="/2023/01/22/c-biao-zhun-mo-ban-ku-stl/"/>
      <url>/2023/01/22/c-biao-zhun-mo-ban-ku-stl/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是C-标准模板库（STL）？"><a href="#什么是C-标准模板库（STL）？" class="headerlink" title="什么是C++标准模板库（STL）？"></a>什么是C++标准模板库（STL）？</h2><p>标准模板库 STL（Standard Template Library），是 C++ 标准库的一部分，不需要单独安装，只需要#include 头文件。</p><p>C++ 对模板（Template）支持得很好，STL 就是借助模板把常用的数据结构及其算法都实现了一遍，并且做到了数据结构和算法的分离。</p><p>C++ 语言的核心优势之一就是便于软件的复用。</p><p>C++ 语言有两个方面体现了复用：</p><p>1.面向对象的继承和多态机制<br>2.通过模板的概念实现了对泛型程序设计的支持</p><p>STL有什么优势？<br>STL封装了很多实用的容器，省时省力，能够让你将更多心思放到解决问题的步骤上，而非费力去实现数据结构诸多细节上，像极了用python时候的酣畅淋漓。<br><em>P.S. 如果对STL源码有兴趣，可读C++大师侯捷的《STL源码剖析》</em></p><h2 id="STL六大部件"><a href="#STL六大部件" class="headerlink" title="STL六大部件"></a>STL六大部件</h2><h2 id="容器（Containers）"><a href="#容器（Containers）" class="headerlink" title="容器（Containers）"></a>容器（Containers）</h2><p>[vector]<a href="https://myq0721.github.io/2023/02/05/vector-yong-fa-zong-jie/">https://myq0721.github.io/2023/02/05/vector-yong-fa-zong-jie/</a></p><h3 id="分配器（Allocators）"><a href="#分配器（Allocators）" class="headerlink" title="分配器（Allocators）"></a>分配器（Allocators）</h3><h3 id="算法（Algorithm）"><a href="#算法（Algorithm）" class="headerlink" title="算法（Algorithm）"></a>算法（Algorithm）</h3><h3 id="迭代器（Iterators）"><a href="#迭代器（Iterators）" class="headerlink" title="迭代器（Iterators）"></a>迭代器（Iterators）</h3><h3 id="适配器（Adapters）"><a href="#适配器（Adapters）" class="headerlink" title="适配器（Adapters）"></a>适配器（Adapters）</h3><h3 id="仿函数（Functors）"><a href="#仿函数（Functors）" class="headerlink" title="仿函数（Functors）"></a>仿函数（Functors）</h3><p><em>详细</em><br><em><a href="https://zhuanlan.zhihu.com/p/344558356">https://zhuanlan.zhihu.com/p/344558356</a></em></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>日语语法——1.名词谓语句</title>
      <link href="/2023/01/22/ri-yu-yu-fa-1.ming-ci-wei-yu-ju/"/>
      <url>/2023/01/22/ri-yu-yu-fa-1.ming-ci-wei-yu-ju/</url>
      
        <content type="html"><![CDATA[<h1 id="日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。"><a href="#日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。" class="headerlink" title="日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。"></a>日语中形容词和动词可直接作谓语，而名词不行。若需用名词作谓语，则需要借助助动词来表达。</h1><h3 id="だ-表达判断"><a href="#だ-表达判断" class="headerlink" title="~だ 表达判断"></a>~だ 表达判断</h3><p>学生だ<br>是学生</p><p>学生ではない<br>不是学生</p><p>学生（か）？<br>是学生吗？</p><h3 id="です-表达判断（对听话人礼貌）"><a href="#です-表达判断（对听话人礼貌）" class="headerlink" title="~です　表达判断（对听话人礼貌）"></a>~です　表达判断（对听话人礼貌）</h3><p>学生です<br>是学生</p><p>学生でわありませえ<br>不是学生</p><p>学生ですか？<br>是学生吗？</p><p>先生ですか、学生ですか。//前读降调后读声调<br>是老师还是学生</p><h3 id="である-表判断（用在演讲或论文中，非常正式）"><a href="#である-表判断（用在演讲或论文中，非常正式）" class="headerlink" title="~である　表判断（用在演讲或论文中，非常正式）"></a>~である　表判断（用在演讲或论文中，非常正式）</h3><p>学生である</p><p>学生であります</p><h3 id="でございます（敬语，店家对客人等）"><a href="#でございます（敬语，店家对客人等）" class="headerlink" title="~でございます（敬语，店家对客人等）"></a>~でございます（敬语，店家对客人等）</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th align="center"></th><th align="center">一般</th><th align="center">礼貌</th><th align="center">正式</th><th align="center">正式+礼貌</th><th align="center">郑重</th></tr></thead><tbody><tr><td align="center">肯定</td><td align="center">だ</td><td align="center">です</td><td align="center">である</td><td align="center">であります</td><td align="center">でございます</td></tr><tr><td align="center">否定</td><td align="center">ではない</td><td align="center">ではありません</td><td align="center">/</td><td align="center">/</td><td align="center">/</td></tr></tbody></table><hr><h3 id="は-x2F-が"><a href="#は-x2F-が" class="headerlink" title="~は/が"></a>~は/が</h3><ul><li><p>你是谁？<br>我是学生。——&gt; 私は学生だ。//强调は后的部分</p></li><li><p>谁是学生？<br>我是学生。——&gt; 私が学生だ。//强调が前的部分</p></li></ul><h3 id="も"><a href="#も" class="headerlink" title="~も"></a>~も</h3><p>我是学生，他也是学生。<br>私は学生です。彼も学生です。//</p>]]></content>
      
      
      
        <tags>
            
            <tag> 日语 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown基础语法</title>
      <link href="/2023/01/20/markdown-ji-chu-yu-fa/"/>
      <url>/2023/01/20/markdown-ji-chu-yu-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是Markdown"><a href="#什么是Markdown" class="headerlink" title="什么是Markdown?"></a>什么是Markdown?</h2><p>&nbsp;  Markdown就是一种文档的格式，文件名的末尾是.md，正如我们常用的word文档格式是.doc、.docx，需要对应的软件来打开这一种格式。</p><h2 id="为什么要用Markdown？"><a href="#为什么要用Markdown？" class="headerlink" title="为什么要用Markdown？"></a>为什么要用Markdown？</h2><p>作为一种新的文档格式，我们放着这么好的word文档不用却用Markdown是有一些原因的：</p><p>有人发现当他们用Word或者别的文本编辑器写好一篇文章，兴高采烈地发布到博客、论坛、网站上时，发现格式完全乱了，于是需要花费大量的时间来重新排版，处理图片、缩进、字体、加粗、标题等。三番五次之后，开始发现文章写作可能只花了半小时，重新排版就花了十多分钟。更让人不悦的是，当我们要把同一篇文章发布到另一个网页上时，这样的排版还要重新做一次。</p><p>并且习惯了非可视化界面后，使用鼠标操作意味着终断打字，是一个显著降低输入速度的行为。一般来说文章的编写必然需要设置一定的格式：标题、加粗、行距、缩进、字体……这些一般都需要用鼠标在可视化界面上选择。</p><h2 id="1-删除线："><a href="#1-删除线：" class="headerlink" title="1.删除线："></a>1.删除线：</h2><p>用法：<code>~~要划删除线的文字~~</code></p><p>例如：<code>~~HelloWorld~~</code></p><p>显示：<del>HelloWorld</del></p><h2 id="2-下划线："><a href="#2-下划线：" class="headerlink" title="2.下划线："></a>2.下划线：</h2><p>用法：<code>&lt;u&gt;要添加下划线的文字&lt;/u&gt;</code></p><p>例如：<code>&lt;u&gt;HelloWorld&lt;/u&gt;</code></p><p>显示：<u>HelloWorld</u></p><h2 id="3-分割线："><a href="#3-分割线：" class="headerlink" title="3.分割线："></a>3.分割线：</h2><p>用法：<code>---</code>  <em>//需要单独的一行！</em></p><p>例如：<code>---</code></p><p>显示：</p><hr><h2 id="4-标题："><a href="#4-标题：" class="headerlink" title="4.标题："></a>4.标题：</h2><p>用法：<code># 标题内容</code> // 需要单独一行</p><p><em>如果需要标题下面的小标题可以多加一个“#”符号</em></p><p>例如：<code># 显示效果</code></p><p>显示：</p><h1 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h1><h2 id="5-加粗："><a href="#5-加粗：" class="headerlink" title="5.加粗："></a>5.加粗：</h2><p>用法：<code>**加粗内容**</code></p><p>例如：<code>**HelloWorld**</code></p><p>显示：<strong>HelloWorld</strong></p><h2 id="6-斜体："><a href="#6-斜体：" class="headerlink" title="6.斜体："></a>6.斜体：</h2><p>用法：<code>*斜体内容*</code></p><p>例如：<code>*HelloWorld*</code></p><p>显示：<em>HelloWorld</em></p><h2 id="7-既斜体又加粗："><a href="#7-既斜体又加粗：" class="headerlink" title="7.既斜体又加粗："></a>7.既斜体又加粗：</h2><p>用法：<code>***斜体又加粗内容***</code></p><p>例如：<code>***HelloWorld***</code></p><p>显示：<em><strong>HelloWorld</strong></em></p><h2 id="8-无序列表："><a href="#8-无序列表：" class="headerlink" title="8.无序列表："></a>8.无序列表：</h2><p>用法：<code>- 内容</code> // 需要单独一行</p><p>例如：</p><p><code>- HelloWorld</code></p><p><code>- HelloMarkdown</code></p><p>显示：</p><ul><li><p>HelloWorld</p></li><li><p>HelloMarkdown</p></li></ul><h2 id="9-有序列表："><a href="#9-有序列表：" class="headerlink" title="9.有序列表："></a>9.有序列表：</h2><p>用法：</p><p><code>1. 内容</code></p><p><code>2. 内容</code></p><p><code>3. 内容</code></p><p>// 可以不按数字顺序，但必须从1开始</p><p>例如：</p><p><code>1. HelloWorld</code></p><p><code>2. HelloMarkdown</code></p><p><code>3. Markdown yes</code></p><p>显示：</p><ol><li><p>HelloWorld</p></li><li><p>HelloMarkdown</p></li><li><p>Markdown yes</p></li></ol><h2 id="10-引用内容："><a href="#10-引用内容：" class="headerlink" title="10.引用内容："></a>10.引用内容：</h2><h2 id="单行："><a href="#单行：" class="headerlink" title="单行："></a>单行：</h2><p>用法：<code>&gt; 引用内容</code> //  需要单独一行</p><p>例如：<code>&gt; HelloWorld by Markdown</code></p><p>显示：</p><blockquote><p>HelloWorld by Markdown</p></blockquote><h2 id="空行："><a href="#空行：" class="headerlink" title="空行："></a>空行：</h2><p>用法：</p><p><code>&gt; 第一行</code></p><p><code>&gt;</code></p><p><code>&gt; 第二行</code></p><p>例如：</p><p><code>&gt; HelloWorld by Markdown 1</code></p><p><code>&gt;</code></p><p><code>&gt; HelloWorld by Markdown 2</code></p><p>显示：</p><blockquote><p>HelloWorld by Markdown 1</p><p>HelloWorld by Markdown 2</p></blockquote><h2 id="嵌套："><a href="#嵌套：" class="headerlink" title="嵌套："></a>嵌套：</h2><p>用法：</p><p><code>&gt; 第一行</code></p><p><code>&gt; 第二行</code></p><p><code>&gt; &gt; 第二行引用的（需要嵌套的）</code></p><p>例如：</p><p><code>&gt; HelloWorld by Markdown 1</code></p><p><code>&gt; HelloWorld by Markdown 2</code></p><p><code>&gt; &gt; HelloWorld by Markdown 3</code></p><p>显示：</p><blockquote><p>HelloWorld by Markdown 1</p><p>HelloWorld by Markdown 2</p><blockquote><p>HelloWorld by Markdown 3</p></blockquote></blockquote><h2 id="带有其他语法的引用："><a href="#带有其他语法的引用：" class="headerlink" title="带有其他语法的引用："></a>带有其他语法的引用：</h2><p><code>&gt; ### HelloWorld</code></p><p><code>&gt;</code></p><p><code>&gt; - HelloWorld</code></p><p><code>&gt; - HelloMarkdown</code></p><p><code>&gt; - Markdown yes</code></p><p><code>&gt;</code></p><p><code>&gt; *Hello* **World**</code></p><p>显示：</p><blockquote><h3 id="HelloWorld"><a href="#HelloWorld" class="headerlink" title="HelloWorld"></a>HelloWorld</h3><ul><li>HelloMarkdown</li><li>Markdown  yes</li></ul><p><em>Hello</em> <strong>World</strong></p></blockquote><h2 id="11-代码块："><a href="#11-代码块：" class="headerlink" title="11.代码块："></a>11.代码块：</h2><p>用法：三个```符号（要封口） （可以缩减成一个）</p><p>例如：```HelloWorld （要封口）</p><p>显示：<code>HelloWorld</code></p><h2 id="12-转义字符："><a href="#12-转义字符：" class="headerlink" title="12.转义字符："></a>12.转义字符：</h2><p>可以把本来要用来Markdown语法的字符转成正常字符</p><p>用法：<code>\</code></p><p>例如：<code>\*HelloWorld\*</code></p><p>显示：*HelloWorld*</p><h2 id="13-使用HTML标签："><a href="#13-使用HTML标签：" class="headerlink" title="13.使用HTML标签："></a>13.使用HTML标签：</h2><p>用法：直接写HTML标签</p><p>例如：<code>&lt;u&gt;HelloWorld&lt;/u&gt;</code></p><p>显示：<u>HelloWorld</u></p><p><em>（之前的下划线就是用的HTML标签，而不是Markdown语法）</em></p><h2 id="14-表格："><a href="#14-表格：" class="headerlink" title="14.表格："></a>14.表格：</h2><h2 id="正常"><a href="#正常" class="headerlink" title="正常"></a>正常</h2><p>用法：</p><pre class="line-numbers language-none"><code class="language-none">| 标题1   | 标题2 || -------|------ || 内容1   | 内容3 || 内容2   | 内容4 |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>（“|”是分割，”—“是竖着的分割线加粗）</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">| Syntax      | Description || ----------- | ----------- || Header      | Title       || Paragraph   | Text        |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>显示：</p><table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>Header</td><td>Title</td></tr><tr><td>Paragraph</td><td>Text</td></tr></tbody></table><h2 id="自动对齐"><a href="#自动对齐" class="headerlink" title="自动对齐"></a>自动对齐</h2><p>用法：</p><pre class="line-numbers language-none"><code class="language-none">| 标题1      | 标题2 | 标题3     || :---:        |    :----:   |          :---: || 内容1      | 内容3     | 内容5   || 内容2   | 内容4        |内容6      |<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><table><thead><tr><th align="center">标题1</th><th align="center">标题2</th><th align="center">标题3</th></tr></thead><tbody><tr><td align="center">内容1</td><td align="center">内容3</td><td align="center">内容5</td></tr><tr><td align="center">内容2</td><td align="center">内容4</td><td align="center">内容6</td></tr></tbody></table><h2 id="15-任务完成表"><a href="#15-任务完成表" class="headerlink" title="15.任务完成表"></a>15.任务完成表</h2><p>用法：</p><p><code>- [x] 打钩的内容</code></p><p><code>- [] 不打钩的内容</code></p><p>例如：</p><p><code>- [x] Markdown yes</code></p><p><code>- [] Word Yes</code></p><p>显示</p><ul><li><p><input checked="" disabled="" type="checkbox"> Markdown yes</p></li><li><p><input disabled="" type="checkbox"> Word Yes</p></li></ul><p>更多请看<a href="https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics">https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/markdown-basics</a><br>以及<a href="https://markdown.com.cn/basic-syntax/images.html">https://markdown.com.cn/basic-syntax/images.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matery主题的Front-matter</title>
      <link href="/2023/01/05/matery-zhu-ti-de-front-matter/"/>
      <url>/2023/01/05/matery-zhu-ti-de-front-matter/</url>
      
        <content type="html"><![CDATA[<h2 id="文章-Front-matter-介绍"><a href="#文章-Front-matter-介绍" class="headerlink" title="文章 Front-matter 介绍"></a>文章 Front-matter 介绍</h2><h3 id="Front-matter-选项详解"><a href="#Front-matter-选项详解" class="headerlink" title="Front-matter 选项详解"></a>Front-matter 选项详解</h3><p><code>Front-matter</code> 选项中的所有内容均为<strong>非必填</strong>的。但我仍然建议至少填写 <code>title</code> 和 <code>date</code> 的值。</p><table><thead><tr><th>配置选项</th><th>默认值</th><th>描述</th></tr></thead><tbody><tr><td>title</td><td><code>Markdown</code> 的文件标题</td><td>文章标题，强烈建议填写此选项</td></tr><tr><td>date</td><td>文件创建时的日期时间</td><td>发布时间，强烈建议填写此选项，且最好保证全局唯一</td></tr><tr><td>author</td><td>根 <code>_config.yml</code> 中的 <code>author</code></td><td>文章作者</td></tr><tr><td>img</td><td><code>featureImages</code> 中的某个值</td><td>文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: <code>http://xxx.com/xxx.jpg</code></td></tr><tr><td>top</td><td><code>true</code></td><td>推荐文章（文章是否置顶），如果 <code>top</code> 值为 <code>true</code>，则会作为首页推荐文章</td></tr><tr><td>hide</td><td><code>false</code></td><td>隐藏文章，如果<code>hide</code>值为<code>true</code>，则文章不会在首页显示</td></tr><tr><td>cover</td><td><code>false</code></td><td><code>v1.0.2</code>版本新增，表示该文章是否需要加入到首页轮播封面中</td></tr><tr><td>coverImg</td><td>无</td><td><code>v1.0.2</code>版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片</td></tr><tr><td>password</td><td>无</td><td>文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 <code>password</code> 的值，该值必须是用 <code>SHA256</code> 加密后的密码，防止被他人识破。前提是在主题的 <code>config.yml</code> 中激活了 <code>verifyPassword</code> 选项</td></tr><tr><td>toc</td><td><code>true</code></td><td>是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 <code>config.yml</code> 中激活了 <code>toc</code> 选项</td></tr><tr><td>mathjax</td><td><code>false</code></td><td>是否开启数学公式支持 ，本文章是否开启 <code>mathjax</code>，且需要在主题的 <code>_config.yml</code> 文件中也需要开启才行</td></tr><tr><td>summary</td><td>无</td><td>文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要</td></tr><tr><td>categories</td><td>无</td><td>文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类</td></tr><tr><td>tags</td><td>无</td><td>文章标签，一篇文章可以多个标签</td></tr><tr><td>keywords</td><td>文章标题</td><td>文章关键字，SEO 时需要</td></tr><tr><td>reprintPolicy</td><td>cc_by</td><td>文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个</td></tr></tbody></table><p>以下为文章的 <code>Front-matter</code> 示例。</p><h3 id="最简示例"><a href="#最简示例" class="headerlink" title="最简示例"></a>最简示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="最全示例"><a href="#最全示例" class="headerlink" title="最全示例"></a>最全示例</h3><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token punctuation">---</span><span class="token key atrule">title</span><span class="token punctuation">:</span> typora<span class="token punctuation">-</span>vue<span class="token punctuation">-</span>theme主题介绍<span class="token key atrule">date</span><span class="token punctuation">:</span> <span class="token datetime number">2018-09-07 09:25:00</span><span class="token key atrule">author</span><span class="token punctuation">:</span> 赵奇<span class="token key atrule">img</span><span class="token punctuation">:</span> /source/images/xxx.jpg<span class="token key atrule">top</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">hide</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">cover</span><span class="token punctuation">:</span> <span class="token boolean important">true</span><span class="token key atrule">coverImg</span><span class="token punctuation">:</span> /images/1.jpg<span class="token key atrule">password</span><span class="token punctuation">:</span> 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92<span class="token key atrule">toc</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">mathjax</span><span class="token punctuation">:</span> <span class="token boolean important">false</span><span class="token key atrule">summary</span><span class="token punctuation">:</span> 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要<span class="token key atrule">categories</span><span class="token punctuation">:</span> Markdown<span class="token key atrule">tags</span><span class="token punctuation">:</span>  <span class="token punctuation">-</span> Typora  <span class="token punctuation">-</span> Markdown<span class="token punctuation">---</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>摘自matery的README_CN，方便自己使用</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ayanami的第一篇blog</title>
      <link href="/2022/03/20/ling-bo-de-di-yi-pian-bo-ke-wen-zhang/"/>
      <url>/2022/03/20/ling-bo-de-di-yi-pian-bo-ke-wen-zhang/</url>
      
        <content type="html"><![CDATA[<h2 id="使用笔记"><a href="#使用笔记" class="headerlink" title="使用笔记"></a>使用笔记</h2><p>node -v#查看node版本<br>npm -v#查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>#安装淘宝的cnpm 管理器<br>cnpm -v#查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v#查看hexo版本<br>mkdir blog#创建blog目录<br>cd blog #进入blog目录<br>sudo hexo init #生成博客 初始化博客<br>hexo s#启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>#本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件</p><p>#配置_config.yml<br>    # Deployment<br>    ## Docs: <a href="https://hexo.io/docs/deployment.html">https://hexo.io/docs/deployment.html</a><br>    deploy:<br>          type: git<br>         repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>          branch: master<br>hexo d#部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</p><p> git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到本地</p><p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p><p>hexo c#清理一下<br>hexo g#生成<br>hexo d#部署到远程Github仓库</p>]]></content>
      
      
      
        <tags>
            
            <tag> others </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/03/20/hello-world/"/>
      <url>/2022/03/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
